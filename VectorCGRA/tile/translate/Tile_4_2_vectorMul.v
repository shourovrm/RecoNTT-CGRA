//-------------------------------------------------------------------------
// TileRTL__e04244646baa657d.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct CGRAData_32_1_1 Definition
// At BitStruct CGRAData_32_1_1
typedef struct packed {
  logic [31:0] payload ;
  logic [0:0] predicate ;
  logic [0:0] bypass ;
} CGRAData_32_1_1;

// PyMTL BitStruct CGRAConfig_6_4_6_8 Definition
// At BitStruct CGRAConfig_6_4_6_8
typedef struct packed {
  logic [5:0] ctrl ;
  logic [0:0] predicate ;
  logic [3:0][2:0] fu_in ;
  logic [7:0][2:0] outport ;
  logic [5:0][0:0] predicate_in ;
} CGRAConfig_6_4_6_8;

// PyMTL BitStruct CGRAData_1_1 Definition
// At BitStruct CGRAData_1_1
typedef struct packed {
  logic [0:0] payload ;
  logic [0:0] predicate ;
} CGRAData_1_1;

// PyMTL Component NormalQueueCtrlRTL Definition
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] deq_en,
  output logic [0:0] deq_rdy,
  input logic [0:0] enq_en,
  output logic [0:0] enq_rdy,
  output logic [0:0] raddr,
  input logic [0:0] reset,
  output logic [0:0] waddr,
  output logic [0:0] wen
);
  localparam logic [0:0] last_idx = 1'd1;
  localparam logic [1:0] num_entries = 2'd2;
  logic [0:0] deq_xfer ;
  logic [0:0] enq_xfer ;
  logic [0:0] head ;
  logic [0:0] tail ;

  // PyMTL Lambda Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:86
  // s.deq_rdy //= lambda: ~s.reset & ( s.count > CountType(0) )
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_deq_rdy
    deq_rdy = ( ~reset ) & ( count > 2'd0 );
  end

  // PyMTL Lambda Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:89
  // s.deq_xfer //= lambda: s.deq_en & s.deq_rdy
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_deq_xfer
    deq_xfer = deq_en & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:85
  // s.enq_rdy //= lambda: ~s.reset & ( s.count < s.num_entries )
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_enq_rdy
    enq_rdy = ( ~reset ) & ( count < num_entries );
  end

  // PyMTL Lambda Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:88
  // s.enq_xfer //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_enq_xfer
    enq_xfer = enq_en & enq_rdy;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:91
  // @s.update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= PtrType(0)
  //     s.tail  <<= PtrType(0)
  //     s.count <<= CountType(0)
  // 
  //   else:
  //     if s.deq_xfer:
  //       s.head <<= s.head + PtrType(1) if s.head < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer:
  //       s.tail <<= s.tail + PtrType(1) if s.tail < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer & ~s.deq_xfer:
  //       s.count <<= s.count + CountType(1)
  //     if ~s.enq_xfer & s.deq_xfer:
  //       s.count <<= s.count - CountType(1)
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( deq_xfer ) begin
        head <= ( head < last_idx ) ? head + 1'd1 : 1'd0;
      end
      if ( enq_xfer ) begin
        tail <= ( tail < last_idx ) ? tail + 1'd1 : 1'd0;
      end
      if ( enq_xfer & ( ~deq_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~enq_xfer ) & deq_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = enq_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAData_32_1_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__e355018d318c7c45
(
  input logic [0:0] clk,
  input logic [0:0] raddr [0:0],
  output CGRAData_32_1_1 rdata [0:0],
  input logic [0:0] reset,
  input logic [0:0] waddr [0:0],
  input CGRAData_32_1_1 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAData_32_1_1 regs [0:1] ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueDpathRTL__EntryType_CGRAData_32_1_1__num_entries_2
(
  input logic [0:0] clk,
  output CGRAData_32_1_1 deq_ret,
  input CGRAData_32_1_1 enq_msg,
  input logic [0:0] raddr,
  input logic [0:0] reset,
  input logic [0:0] waddr,
  input logic [0:0] wen
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk ;
  logic [0:0] queue__raddr [0:0] ;
  CGRAData_32_1_1 queue__rdata [0:0] ;
  logic [0:0] queue__reset ;
  logic [0:0] queue__waddr [0:0] ;
  CGRAData_32_1_1 queue__wdata [0:0] ;
  logic [0:0] queue__wen [0:0] ;

  RegisterFile__e355018d318c7c45 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueRTL__EntryType_CGRAData_32_1_1__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] reset,
  input logic [0:0] deq__en,
  output logic [0:0] deq__rdy,
  output CGRAData_32_1_1 deq__ret,
  input logic [0:0] enq__en,
  input CGRAData_32_1_1 enq__msg,
  output logic [0:0] enq__rdy
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk ;
  logic [1:0] ctrl__count ;
  logic [0:0] ctrl__deq_en ;
  logic [0:0] ctrl__deq_rdy ;
  logic [0:0] ctrl__enq_en ;
  logic [0:0] ctrl__enq_rdy ;
  logic [0:0] ctrl__raddr ;
  logic [0:0] ctrl__reset ;
  logic [0:0] ctrl__waddr ;
  logic [0:0] ctrl__wen ;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk ;
  CGRAData_32_1_1 dpath__deq_ret ;
  CGRAData_32_1_1 dpath__enq_msg ;
  logic [0:0] dpath__raddr ;
  logic [0:0] dpath__reset ;
  logic [0:0] dpath__waddr ;
  logic [0:0] dpath__wen ;

  NormalQueueDpathRTL__EntryType_CGRAData_32_1_1__num_entries_2 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component ChannelRTL Definition
// At /home/cheng/workspace/projects/cgra/vrsa/noc/ChannelRTL.py

module ChannelRTL__DataType_CGRAData_32_1_1__latency_1
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] reset,
  input logic [0:0] recv__en,
  input CGRAData_32_1_1 recv__msg,
  output logic [0:0] recv__rdy,
  output logic [0:0] send__en,
  output CGRAData_32_1_1 send__msg,
  input logic [0:0] send__rdy
);
  localparam CGRAData_32_1_1 data = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] latency = 32'd1;
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0] ;
  logic [1:0] queues__count [0:0] ;
  logic [0:0] queues__reset [0:0] ;
  logic [0:0] queues__deq__en [0:0] ;
  logic [0:0] queues__deq__rdy [0:0] ;
  CGRAData_32_1_1 queues__deq__ret [0:0] ;
  logic [0:0] queues__enq__en [0:0] ;
  CGRAData_32_1_1 queues__enq__msg [0:0] ;
  logic [0:0] queues__enq__rdy [0:0] ;

  NormalQueueRTL__EntryType_CGRAData_32_1_1__num_entries_2 queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .deq__en( queues__deq__en[0] ),
    .deq__rdy( queues__deq__rdy[0] ),
    .deq__ret( queues__deq__ret[0] ),
    .enq__en( queues__enq__en[0] ),
    .enq__msg( queues__enq__msg[0] ),
    .enq__rdy( queues__enq__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/noc/ChannelRTL.py:35
  //   @s.update
  //   def process():
  //     if s.recv.msg.bypass == b1( 0 ):
  //       s.recv.rdy = s.queues[0].enq.rdy
  //       s.queues[0].enq.msg = s.recv.msg
  //       s.queues[0].enq.en  = s.recv.en and s.queues[0].enq.rdy
  //       for i in range(s.latency - 1):
  //         s.queues[i+1].enq.msg = s.queues[i].deq.ret
  //         s.queues[i+1].enq.en  = s.queues[i].deq.rdy and s.queues[i+1].enq.rdy
  //         s.queues[i].deq.en    = s.queues[i+1].enq.en
  // 
  //       s.send.msg  = s.queues[s.latency-1].deq.ret
  //       s.send.en   = s.send.rdy and s.queues[s.latency-1].deq.rdy
  //       s.queues[s.latency-1].deq.en   = s.send.en
  //     else:
  //       s.send.msg = s.data
  //       s.send.msg.payload = s.recv.msg.payload
  //       s.send.msg.predicate = s.recv.msg.predicate
  //       s.send.msg.bypass = b1( 0 )
  //       s.send.en = s.send.rdy and s.recv.en
  //       s.recv.rdy = s.send.rdy
  
  always_comb begin : process
    if ( recv__msg.bypass == 1'd0 ) begin
      recv__rdy = queues__enq__rdy[0];
      queues__enq__msg[0] = recv__msg;
      queues__enq__en[0] = recv__en && queues__enq__rdy[0];
      for ( int i = 0; i < latency - 1; i += 1 ) begin
        queues__enq__msg[i + 1] = queues__deq__ret[i];
        queues__enq__en[i + 1] = queues__deq__rdy[i] && queues__enq__rdy[i + 1];
        queues__deq__en[i] = queues__enq__en[i + 1];
      end
      send__msg = queues__deq__ret[latency - 1];
      send__en = send__rdy && queues__deq__rdy[latency - 1];
      queues__deq__en[latency - 1] = send__en;
    end
    else begin
      send__msg = data;
      send__msg.payload = recv__msg.payload;
      send__msg.predicate = recv__msg.predicate;
      send__msg.bypass = 1'd0;
      send__en = send__rdy && recv__en;
      recv__rdy = send__rdy;
    end
  end

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign count = queues__count[0];

endmodule


// PyMTL Component CrossbarRTL Definition
// Full name: CrossbarRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_6__num_outports_8__bypass_point_4__id_0
// At /home/cheng/workspace/projects/cgra/vrsa/noc/CrossbarRTL.py

module CrossbarRTL__20918f721d5f331c
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_data__en [0:5],
  input CGRAData_32_1_1 recv_data__msg [0:5],
  output logic [0:0] recv_data__rdy [0:5],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  output logic [0:0] send_data__en [0:7],
  output CGRAData_32_1_1 send_data__msg [0:7],
  input logic [0:0] send_data__rdy [0:7],
  output logic [0:0] send_predicate__en,
  output CGRAData_1_1 send_predicate__msg,
  input logic [0:0] send_predicate__rdy
);
  localparam logic [31:0] bypass_point = 32'd4;
  localparam logic [5:0] __const__OPT_START = 6'd0;
  localparam logic [31:0] __const__num_inports_at_update_signal = 32'd6;
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd8;
  logic [0:0] __tmpvar__update_signal_out_rdy ;
  logic [2:0] __tmpvar__update_signal_in_dir ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/noc/CrossbarRTL.py:34
  //     @s.update
  //     def update_signal():
  //       out_rdy = b1( 0 )
  //       s.send_predicate.en = b1( 0 )
  //       # predicate_out_rdy = b1( 0 )
  //       # For predication register update. 'predicate' and 'predicate_in' no need
  //       # to be active at the same time. Specifically, the 'predicate' is for
  //       # the operation at the current cycle while the 'predicate_in' accumulates
  //       # the predicate and pushes into the predicate register that will be used
  //       # in the future.
  //       if s.recv_opt.msg.predicate == b1( 1 ):
  //         # s.send_predicate.msg.payload = b1( 0 )
  //         # s.send_predicate.msg.predicate = b1( 0 )
  //         s.send_predicate.msg = PredicateType( b1(0), b1(0) )
  //       if s.recv_opt.msg.ctrl != OPT_START:
  //         for i in range( num_inports ):
  //           # Set predicate once the recv_data is stable (i.e., en == true).
  //           if s.recv_opt.msg.predicate_in[i] == b1( 1 ) and s.recv_data[i].en == b1( 1 ):
  //             s.send_predicate.en = b1( 1 )
  //             s.send_predicate.msg.payload = b1( 1 )
  //             s.send_predicate.msg.predicate = s.send_predicate.msg.predicate | s.recv_data[i].msg.predicate
  //             # predicate_out_rdy = b1( 1 )
  //         for i in range( num_outports ):
  //           in_dir  = s.recv_opt.msg.outport[i]
  //           out_rdy = out_rdy | s.send_data[i].rdy
  // #          s.send_data[i].msg.bypass = b1( 0 ) 
  //           if in_dir > OutType( 0 ) and s.send_data[i].rdy:
  //             in_dir = in_dir - OutType( 1 )
  //             s.recv_data[in_dir].rdy = s.send_data[i].rdy
  //             s.send_data[i].en       = s.recv_data[in_dir].en
  //             if s.send_data[i].en and s.recv_data[in_dir].rdy:
  //               s.send_data[i].msg.payload   = s.recv_data[in_dir].msg.payload
  //               s.send_data[i].msg.predicate = s.recv_data[in_dir].msg.predicate
  // #              s.send_data[i].msg = s.recv_data[in_dir].msg
  //               s.send_data[i].msg.bypass    = s.recv_data[in_dir].msg.bypass
  //             # The generate one can be send to other tile without buffering,
  //             # but buffering is still needed when 'other tile' is yourself
  //             # (i.e., generating output to self input). Here we avoid self 
  //             # connecting by checking whether the inport belongs to FU and
  //             # outport be towards to remote tiles to eliminate combinational
  //             # loop.
  //             if in_dir >= OutType( s.bypass_point ) and i<s.bypass_point:
  //               s.send_data[i].msg.bypass = b1( 1 ) 
  // #              print("in crossbar ", s, " set bypass ... s.recv_opt.msg.outport[", i, "]: ", s.recv_opt.msg.outport[i])
  //             else:
  //               s.send_data[i].msg.bypass = b1( 0 ) 
  // #            print("in crossbar if... s.send_data[", i, "].msg: ", s.send_data[i].msg, "; recv.rdy: ", s.recv_data[in_dir].rdy)
  //           else:
  //             s.send_data[i].en  = b1( 0 )
  //             #s.send_data[i].msg = b1( 0 )
  // #            print("in crossbar else... s.send_data[", i, "].msg: ", s.send_data[i].msg)
  // 
  //       else:
  //         for i in range( num_outports ):
  // #          s.send_data[i].msg.bypass = b1( 0 ) 
  //           s.send_data[i].en = b1( 0 )
  //       s.recv_opt.rdy = out_rdy# and predicate_out_rdy
  
  always_comb begin : update_signal
    __tmpvar__update_signal_out_rdy = 1'd0;
    send_predicate__en = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_predicate__msg = { 1'd0, 1'd0 };
    end
    if ( recv_opt__msg.ctrl != __const__OPT_START ) begin
      for ( int i = 0; i < __const__num_inports_at_update_signal; i += 1 )
        if ( ( recv_opt__msg.predicate_in[i] == 1'd1 ) && ( recv_data__en[i] == 1'd1 ) ) begin
          send_predicate__en = 1'd1;
          send_predicate__msg.payload = 1'd1;
          send_predicate__msg.predicate = send_predicate__msg.predicate | recv_data__msg[i].predicate;
        end
      for ( int i = 0; i < __const__num_outports_at_update_signal; i += 1 ) begin
        __tmpvar__update_signal_in_dir = recv_opt__msg.outport[i];
        __tmpvar__update_signal_out_rdy = __tmpvar__update_signal_out_rdy | send_data__rdy[i];
        if ( ( __tmpvar__update_signal_in_dir > 3'd0 ) && send_data__rdy[i] ) begin
          __tmpvar__update_signal_in_dir = __tmpvar__update_signal_in_dir - 3'd1;
          recv_data__rdy[__tmpvar__update_signal_in_dir] = send_data__rdy[i];
          send_data__en[i] = recv_data__en[__tmpvar__update_signal_in_dir];
          if ( send_data__en[i] && recv_data__rdy[__tmpvar__update_signal_in_dir] ) begin
            send_data__msg[i].payload = recv_data__msg[__tmpvar__update_signal_in_dir].payload;
            send_data__msg[i].predicate = recv_data__msg[__tmpvar__update_signal_in_dir].predicate;
            send_data__msg[i].bypass = recv_data__msg[__tmpvar__update_signal_in_dir].bypass;
          end
          if ( ( __tmpvar__update_signal_in_dir >= 3'( bypass_point ) ) && ( i < bypass_point ) ) begin
            send_data__msg[i].bypass = 1'd1;
          end
          else
            send_data__msg[i].bypass = 1'd0;
        end
        else
          send_data__en[i] = 1'd0;
      end
    end
    else
      for ( int i = 0; i < __const__num_outports_at_update_signal; i += 1 )
        send_data__en[i] = 1'd0;
    recv_opt__rdy = __tmpvar__update_signal_out_rdy;
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAConfig_6_4_6_8__nregs_3__rd_ports_1__wr_ports_1__const_zero_False
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__63449cda1f03128c
(
  input logic [0:0] clk,
  input logic [1:0] raddr [0:0],
  output CGRAConfig_6_4_6_8 rdata [0:0],
  input logic [0:0] reset,
  input logic [1:0] waddr [0:0],
  input CGRAConfig_6_4_6_8 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAConfig_6_4_6_8 regs [0:2] ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component CtrlMemRTL Definition
// Full name: CtrlMemRTL__CtrlType_CGRAConfig_6_4_6_8__ctrl_mem_size_3__num_ctrl_3
// At /home/cheng/workspace/projects/cgra/vrsa/mem/ctrl/CtrlMemRTL.py

module CtrlMemRTL__8f238acfb01302b1
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_ctrl__en,
  input CGRAConfig_6_4_6_8 recv_ctrl__msg,
  output logic [0:0] recv_ctrl__rdy,
  input logic [0:0] recv_waddr__en,
  input logic [1:0] recv_waddr__msg,
  output logic [0:0] recv_waddr__rdy,
  output logic [0:0] send_ctrl__en,
  output CGRAConfig_6_4_6_8 send_ctrl__msg,
  input logic [0:0] send_ctrl__rdy
);
  localparam logic [31:0] __const__num_ctrl_at_update_signal = 32'd3;
  localparam logic [5:0] __const__OPT_START = 6'd0;
  localparam logic [31:0] __const__num_ctrl_at_update_raddr = 32'd3;
  localparam logic [1:0] __const__last_item_at_update_raddr = 2'd2;
  logic [1:0] times ;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk ;
  logic [1:0] reg_file__raddr [0:0] ;
  CGRAConfig_6_4_6_8 reg_file__rdata [0:0] ;
  logic [0:0] reg_file__reset ;
  logic [1:0] reg_file__waddr [0:0] ;
  CGRAConfig_6_4_6_8 reg_file__wdata [0:0] ;
  logic [0:0] reg_file__wen [0:0] ;

  RegisterFile__63449cda1f03128c reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/mem/ctrl/CtrlMemRTL.py:42
  // @s.update
  // def update_signal():
  //   if s.times == TimeType( num_ctrl ) or s.reg_file.rdata[0].ctrl == OPT_START:
  //     s.send_ctrl.en = b1( 0 )
  //   else:
  //     s.send_ctrl.en  = s.send_ctrl.rdy # s.recv_raddr[i].rdy
  //   s.recv_waddr.rdy = b1( 1 )
  //   s.recv_ctrl.rdy = b1( 1 )
  
  always_comb begin : update_signal
    if ( ( times == 2'd3 ) || ( reg_file__rdata[0].ctrl == __const__OPT_START ) ) begin
      send_ctrl__en = 1'd0;
    end
    else
      send_ctrl__en = send_ctrl__rdy;
    recv_waddr__rdy = 1'd1;
    recv_ctrl__rdy = 1'd1;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/mem/ctrl/CtrlMemRTL.py:51
  // @s.update_ff
  // def update_raddr():
  //   if s.reg_file.rdata[0].ctrl != OPT_START:
  //     if s.times < TimeType( num_ctrl ):
  //       s.times <<= s.times + TimeType( 1 )
  //     if s.reg_file.raddr[0] < last_item:
  //       s.reg_file.raddr[0] <<= s.reg_file.raddr[0] + AddrType( 1 )
  //     else:
  //       s.reg_file.raddr[0] <<= AddrType( 0 )
  
  always_ff @(posedge clk) begin : update_raddr
    if ( reg_file__rdata[0].ctrl != __const__OPT_START ) begin
      if ( times < 2'd3 ) begin
        times <= times + 2'd1;
      end
      if ( reg_file__raddr[0] < __const__last_item_at_update_raddr ) begin
        reg_file__raddr[0] <= reg_file__raddr[0] + 2'd1;
      end
      else
        reg_file__raddr[0] <= 2'd0;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;
  assign send_ctrl__msg = reg_file__rdata[0];
  assign reg_file__waddr[0] = recv_waddr__msg;
  assign reg_file__wdata[0] = recv_ctrl__msg;
  assign reg_file__wen[0] = recv_waddr__en;

endmodule


// PyMTL Component AdderRTL Definition
// Full name: AdderRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/AdderRTL.py

module AdderRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_one = { 32'd1, 1'd1, 1'd0 };
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_ADD = 6'd2;
  localparam logic [5:0] __const__OPT_ADD_CONST = 6'd25;
  localparam logic [5:0] __const__OPT_INC = 6'd3;
  localparam logic [5:0] __const__OPT_SUB = 6'd4;
  localparam logic [5:0] __const__OPT_PAS = 6'd31;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/AdderRTL.py:31
  //     @s.update
  //     def comb_logic():
  // 
  //       # For pick input register
  //       in0 = FuInType( 0 )
  //       in1 = FuInType( 0 )
  //       for i in range( num_inports ):
  //         s.recv_in[i].rdy = b1( 0 )
  // 
  //       s.recv_predicate.rdy = b1( 0 )
  // 
  //       if s.recv_opt.en:
  //         if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //           in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //           s.recv_in[in0].rdy = b1( 1 )
  //         if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //           in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //           s.recv_in[in1].rdy = b1( 1 )
  //         if s.recv_opt.msg.predicate == b1( 1 ):
  //           s.recv_predicate.rdy = b1( 1 )
  // 
  //       s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                       s.recv_in[in1].msg.predicate
  // 
  //       for j in range( num_outports ):
  //         s.send_out[j].en = s.recv_opt.en
  // 
  // #      s.send_out[0].en = s.recv_opt.en
  // 
  //       if s.recv_opt.msg.ctrl == OPT_ADD:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload + s.recv_in[in1].msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and s.recv_in[in1].msg.predicate
  //         if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                                s.recv_in_count[in1] == CountType( 0 ) ):
  //           s.recv_in[in0].rdy = b1( 0 )
  //           s.recv_in[in1].rdy = b1( 0 )
  //           s.send_out[0].msg.predicate = b1( 0 )
  //       elif s.recv_opt.msg.ctrl == OPT_ADD_CONST:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload + s.recv_const.msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //       elif s.recv_opt.msg.ctrl == OPT_INC:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload + s.const_one.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //       elif s.recv_opt.msg.ctrl == OPT_SUB:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload - s.recv_in[in1].msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //         if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                                s.recv_in_count[in1] == CountType( 0 ) ):
  //           s.recv_in[in0].rdy = b1( 0 )
  //           s.recv_in[in1].rdy = b1( 0 )
  //           s.send_out[0].msg.predicate = b1( 0 )
  //       elif s.recv_opt.msg.ctrl == OPT_PAS:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //       else:
  //         for j in range( num_outports ):
  //           s.send_out[j].en = b1( 0 )
  // 
  //       if s.recv_opt.msg.predicate == b1( 1 ):
  //         s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                       s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_ADD ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload + recv_in__msg[__tmpvar__comb_logic_in1].payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_ADD_CONST ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload + recv_const__msg.payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_INC ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload + const_one.payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_SUB ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload - recv_in__msg[__tmpvar__comb_logic_in1].payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_PAS ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:47
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:41
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component MulRTL Definition
// Full name: MulRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/MulRTL.py

module MulRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_MUL = 6'd7;
  localparam logic [5:0] __const__OPT_MUL_CONST = 6'd29;
  localparam logic [5:0] __const__OPT_DIV = 6'd26;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/MulRTL.py:28
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                 s.recv_in[in1].msg.predicate
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  //   if s.recv_opt.msg.ctrl == OPT_MUL:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload * s.recv_in[in1].msg.payload
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  //   elif s.recv_opt.msg.ctrl == OPT_MUL_CONST:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload * s.recv_const.msg.payload
  //     s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //   elif s.recv_opt.msg.ctrl == OPT_DIV:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload / s.recv_in[in1].msg.payload
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_MUL ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload * recv_in__msg[__tmpvar__comb_logic_in1].payload;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_MUL_CONST ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload * recv_const__msg.payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_DIV ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload / recv_in__msg[__tmpvar__comb_logic_in1].payload;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:47
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:41
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component LogicRTL Definition
// Full name: LogicRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/LogicRTL.py

module LogicRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_OR = 6'd8;
  localparam logic [5:0] __const__OPT_AND = 6'd10;
  localparam logic [5:0] __const__OPT_NOT = 6'd11;
  localparam logic [5:0] __const__OPT_XOR = 6'd9;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/LogicRTL.py:29
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                 s.recv_in[in1].msg.predicate
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  //   if s.recv_opt.msg.ctrl == OPT_OR:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload | s.recv_in[in1].msg.payload
  //   elif s.recv_opt.msg.ctrl == OPT_AND:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload & s.recv_in[in1].msg.payload
  //   elif s.recv_opt.msg.ctrl == OPT_NOT:
  //     s.send_out[0].msg.payload = ~ s.recv_in[in0].msg.payload
  //   elif s.recv_opt.msg.ctrl == OPT_XOR:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload ^ s.recv_in[in1].msg.payload
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if ( s.recv_opt.msg.ctrl == OPT_OR or s.recv_opt.msg.ctrl == OPT_AND or\
  //        s.recv_opt.msg.ctrl == OPT_XOR ) and s.recv_opt.en and\
  //        ( s.recv_in_count[in0] == CountType( 0 ) or s.recv_in_count[in1] == CountType( 0 ) ):
  //     s.recv_in[in0].rdy = b1( 0 )
  //     s.recv_in[in1].rdy = b1( 0 )
  //     s.send_out[0].msg.predicate = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_OR ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload | recv_in__msg[__tmpvar__comb_logic_in1].payload;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_AND ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload & recv_in__msg[__tmpvar__comb_logic_in1].payload;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_NOT ) begin
      send_out__msg[0].payload = ~recv_in__msg[__tmpvar__comb_logic_in0].payload;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_XOR ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload ^ recv_in__msg[__tmpvar__comb_logic_in1].payload;
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( ( ( recv_opt__msg.ctrl == __const__OPT_OR ) || ( recv_opt__msg.ctrl == __const__OPT_AND ) || ( recv_opt__msg.ctrl == __const__OPT_XOR ) ) && recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
      recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
      recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
      send_out__msg[0].predicate = 1'd0;
    end
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:47
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:41
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component ShifterRTL Definition
// Full name: ShifterRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/ShifterRTL.py

module ShifterRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_LLS = 6'd5;
  localparam logic [5:0] __const__OPT_LRS = 6'd6;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/ShifterRTL.py:29
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                 s.recv_in[in1].msg.predicate
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  //   if s.recv_opt.msg.ctrl == OPT_LLS:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload << s.recv_in[in1].msg.payload
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  //   elif s.recv_opt.msg.ctrl == OPT_LRS:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload >> s.recv_in[in1].msg.payload
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_LLS ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload << recv_in__msg[__tmpvar__comb_logic_in1].payload;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_LRS ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload >> recv_in__msg[__tmpvar__comb_logic_in1].payload;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:47
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:41
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component PhiRTL Definition
// Full name: PhiRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/PhiRTL.py

module PhiRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_PHI = 6'd17;
  localparam logic [5:0] __const__OPT_PHI_CONST = 6'd32;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/PhiRTL.py:30
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  // 
  //   if s.recv_opt.msg.ctrl == OPT_PHI:
  //     if s.recv_in[in0].msg.predicate == Bits1( 1 ):
  //       s.send_out[0].msg.payload   = s.recv_in[in0].msg.payload
  //       s.send_out[0].msg.predicate = Bits1( 1 )
  //     elif s.recv_in[in1].msg.predicate == Bits1( 1 ):
  //       s.send_out[0].msg.payload   = s.recv_in[in1].msg.payload
  //       s.send_out[0].msg.predicate = Bits1( 1 )
  //     else: # No predecessor is active.
  //       s.send_out[0].msg.payload   = s.recv_in[in0].msg.payload
  //       s.send_out[0].msg.predicate = Bits1( 0 )
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy   = b1( 0 )
  //       s.recv_in[in1].rdy   = b1( 0 )
  //       s.recv_predicate.rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  // 
  //     if s.recv_opt.msg.predicate     == b1( 1 ) and\
  //        s.recv_predicate.msg.payload == b1( 0 ):
  //       s.recv_predicate.rdy = b1( 0 )
  //       s.recv_in[in0].rdy   = b1( 0 )
  //       s.recv_in[in1].rdy   = b1( 0 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_PHI_CONST:
  // 
  //     s.send_out[0].msg.predicate = Bits1( 1 )
  //     if s.recv_in[in0].msg.predicate == Bits1( 1 ):
  //       s.send_out[0].msg.payload   = s.recv_in[in0].msg.payload
  //     else:
  //       s.send_out[0].msg.payload   = s.recv_const.msg.payload
  // 
  //     # Predication signal not arrive yet.
  //     if s.recv_opt.msg.predicate     == b1( 1 ) and\
  //        s.recv_predicate.msg.payload == b1( 0 ):
  //       #s.recv_predicate.rdy = b1( 0 )
  //       s.recv_in[in0].rdy   = b1( 0 )
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  // 
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  //     # The PHI_CONST operation executed an the first time does not need predication signal.
  //     if s.recv_opt.msg.ctrl == OPT_PHI_CONST:
  //       if s.recv_predicate.msg.payload == b1( 0 ):
  //         s.send_out[0].msg.predicate = b1( 1 )
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_PHI ) begin
      if ( recv_in__msg[__tmpvar__comb_logic_in0].predicate == 1'd1 ) begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
        send_out__msg[0].predicate = 1'd1;
      end
      else if ( recv_in__msg[__tmpvar__comb_logic_in1].predicate == 1'd1 ) begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in1].payload;
        send_out__msg[0].predicate = 1'd1;
      end
      else begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
        send_out__msg[0].predicate = 1'd0;
      end
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        recv_predicate__rdy = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
      if ( ( recv_opt__msg.predicate == 1'd1 ) && ( recv_predicate__msg.payload == 1'd0 ) ) begin
        recv_predicate__rdy = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_PHI_CONST ) begin
      send_out__msg[0].predicate = 1'd1;
      if ( recv_in__msg[__tmpvar__comb_logic_in0].predicate == 1'd1 ) begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
      end
      else
        send_out__msg[0].payload = recv_const__msg.payload;
      if ( ( recv_opt__msg.predicate == 1'd1 ) && ( recv_predicate__msg.payload == 1'd0 ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
      if ( recv_opt__msg.ctrl == __const__OPT_PHI_CONST ) begin
        if ( recv_predicate__msg.payload == 1'd0 ) begin
          send_out__msg[0].predicate = 1'd1;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:47
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:41
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component CompRTL Definition
// Full name: CompRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/CompRTL.py

module CompRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_one = { 32'd1, 1'd0, 1'd0 };
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_read_reg = 32'd4;
  localparam logic [31:0] __const__num_outports_at_read_reg = 32'd2;
  localparam logic [5:0] __const__OPT_EQ = 6'd14;
  localparam logic [5:0] __const__OPT_EQ_CONST = 6'd33;
  localparam logic [5:0] __const__OPT_LE = 6'd15;
  logic [2:0] __tmpvar__read_reg_in0 ;
  logic [2:0] __tmpvar__read_reg_in1 ;
  logic [0:0] __tmpvar__read_reg_predicate ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/CompRTL.py:34
  // @s.update
  // def read_reg():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 ) 
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  //   s.recv_predicate.rdy = b1( 0 )
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   predicate = s.recv_in[in0].msg.predicate & s.recv_in[in1].msg.predicate
  //   s.send_out[0].msg = s.const_one
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  // 
  //   if s.recv_opt.msg.ctrl == OPT_EQ:
  //     if s.recv_in[in0].msg.payload == s.recv_in[in1].msg.payload:
  //       s.send_out[0].msg = s.const_one
  //       s.send_out[0].msg.predicate = predicate
  //     else:
  //       s.send_out[0].msg = s.const_zero
  //       s.send_out[0].msg.predicate = predicate
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_EQ_CONST:
  //     if s.recv_in[in0].msg.payload == s.recv_const.msg.payload:
  //       s.send_out[0].msg = s.const_one
  //       s.send_out[0].msg.predicate = b1( 1 )
  //     else:
  //       s.send_out[0].msg = s.const_zero
  //       s.send_out[0].msg.predicate = b1( 1 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_LE:
  //     if s.recv_in[in0].msg.payload < s.recv_in[in1].msg.payload:
  //       s.send_out[0].msg = s.const_one
  //       s.send_out[0].msg.predicate = predicate
  //     else:
  //       s.send_out[0].msg = s.const_zero
  //       s.send_out[0].msg.predicate = predicate
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : read_reg
    __tmpvar__read_reg_in0 = 3'd0;
    __tmpvar__read_reg_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_read_reg; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__read_reg_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__read_reg_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__read_reg_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__read_reg_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    __tmpvar__read_reg_predicate = recv_in__msg[__tmpvar__read_reg_in0].predicate & recv_in__msg[__tmpvar__read_reg_in1].predicate;
    send_out__msg[0] = const_one;
    for ( int j = 0; j < __const__num_outports_at_read_reg; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_EQ ) begin
      if ( recv_in__msg[__tmpvar__read_reg_in0].payload == recv_in__msg[__tmpvar__read_reg_in1].payload ) begin
        send_out__msg[0] = const_one;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      else begin
        send_out__msg[0] = const_zero;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__read_reg_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__read_reg_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__read_reg_in0] = 1'd0;
        recv_in__rdy[__tmpvar__read_reg_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_EQ_CONST ) begin
      if ( recv_in__msg[__tmpvar__read_reg_in0].payload == recv_const__msg.payload ) begin
        send_out__msg[0] = const_one;
        send_out__msg[0].predicate = 1'd1;
      end
      else begin
        send_out__msg[0] = const_zero;
        send_out__msg[0].predicate = 1'd1;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_LE ) begin
      if ( recv_in__msg[__tmpvar__read_reg_in0].payload < recv_in__msg[__tmpvar__read_reg_in1].payload ) begin
        send_out__msg[0] = const_one;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      else begin
        send_out__msg[0] = const_zero;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__read_reg_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__read_reg_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__read_reg_in0] = 1'd0;
        recv_in__rdy[__tmpvar__read_reg_in1] = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_read_reg; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:47
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:41
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component BranchRTL Definition
// Full name: BranchRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/BranchRTL.py

module BranchRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_BRH = 6'd16;
  localparam logic [5:0] __const__OPT_BRH_START = 6'd34;
  logic [0:0] first ;
  logic [2:0] __tmpvar__comb_logic_in0 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/BranchRTL.py:30
  //     @s.update
  //     def comb_logic():
  // 
  //       # For pick input register
  //       in0 = FuInType( 0 )
  //       # in1 = FuInType( 0 )
  //       for i in range( num_inports ):
  //         s.recv_in[i].rdy = b1( 0 )
  // 
  //       s.recv_predicate.rdy = b1( 0 )
  // 
  //       if s.recv_opt.en:
  //         if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //           in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //           s.recv_in[in0].rdy = b1( 1 )
  // #        if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  // #          in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  // #          s.recv_in[in1].rdy = b1( 1 )
  // 
  //         if s.recv_opt.msg.predicate == b1( 1 ):
  //           s.recv_predicate.rdy = b1( 1 )
  // 
  // 
  //       for j in range( num_outports ):
  //         s.send_out[j].en = s.recv_opt.en
  //       if s.recv_opt.msg.ctrl == OPT_BRH:
  //         # Branch is only used to set predication rather than delivering value.
  //         s.send_out[0].msg = DataType(0, b1( 0 ), b1( 0 ) )
  //         s.send_out[1].msg = DataType(0, b1( 0 ), b1( 0 ) )
  //         if s.recv_in[in0].msg.payload == s.const_zero.payload:
  //           s.send_out[0].msg.predicate = Bits1( 1 )
  //           s.send_out[1].msg.predicate = Bits1( 0 )
  //         else:
  //           s.send_out[0].msg.predicate = Bits1( 0 )
  //           s.send_out[1].msg.predicate = Bits1( 1 )
  //       elif s.recv_opt.msg.ctrl == OPT_BRH_START:
  //         s.send_out[0].msg = DataType(0, b1( 0 ), b1( 0 ) )
  //         s.send_out[1].msg = DataType(0, b1( 0 ), b1( 0 ) )
  //         if s.first == b1( 1 ):
  //           s.send_out[0].msg.predicate = Bits1( 1 )
  //           s.send_out[1].msg.predicate = Bits1( 0 )
  //         else:
  //           s.send_out[0].msg.predicate = Bits1( 0 )
  //           s.send_out[1].msg.predicate = Bits1( 1 )
  // 
  //       else:
  //         for j in range( num_outports ):
  //           s.send_out[j].en = b1( 0 )
  // 
  //       if s.recv_opt.msg.predicate == b1( 1 ) and s.recv_opt.msg.ctrl != OPT_BRH_START:
  //         # The operation executed on the first cycle gets no input predicate.
  //         s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                        s.recv_predicate.msg.predicate
  //         s.send_out[1].msg.predicate = s.send_out[1].msg.predicate and\
  //                                       s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_BRH ) begin
      send_out__msg[0] = { 0, 1'd0, 1'd0 };
      send_out__msg[1] = { 0, 1'd0, 1'd0 };
      if ( recv_in__msg[__tmpvar__comb_logic_in0].payload == const_zero.payload ) begin
        send_out__msg[0].predicate = 1'd1;
        send_out__msg[1].predicate = 1'd0;
      end
      else begin
        send_out__msg[0].predicate = 1'd0;
        send_out__msg[1].predicate = 1'd1;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_BRH_START ) begin
      send_out__msg[0] = { 0, 1'd0, 1'd0 };
      send_out__msg[1] = { 0, 1'd0, 1'd0 };
      if ( first == 1'd1 ) begin
        send_out__msg[0].predicate = 1'd1;
        send_out__msg[1].predicate = 1'd0;
      end
      else begin
        send_out__msg[0].predicate = 1'd0;
        send_out__msg[1].predicate = 1'd1;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( ( recv_opt__msg.predicate == 1'd1 ) && ( recv_opt__msg.ctrl != __const__OPT_BRH_START ) ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
      send_out__msg[1].predicate = send_out__msg[1].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:47
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/basic/Fu.py:41
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/BranchRTL.py:88
  // @s.update_ff
  // def br_start_once():
  //   if s.reset:
  //     s.first <<= b1( 1 )
  //   if s.recv_opt.msg.ctrl == OPT_BRH_START:
  //     s.first <<= b1( 0 )
  
  always_ff @(posedge clk) begin : br_start_once
    if ( reset ) begin
      first <= 1'd1;
    end
    if ( recv_opt__msg.ctrl == __const__OPT_BRH_START ) begin
      first <= 1'd0;
    end
  end

endmodule


// PyMTL Component MemUnitRTL Definition
// Full name: MemUnitRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/MemUnitRTL.py

module MemUnitRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_LD = 6'd12;
  localparam logic [5:0] __const__OPT_LD_CONST = 6'd28;
  localparam logic [5:0] __const__OPT_STR = 6'd13;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/MemUnitRTL.py:43
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  // 
  //   for j in range( num_outports ):
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  // 
  //   for j in range( num_outports ):
  //     for i in range( num_inports ):
  //       s.send_out[j].en = s.recv_in[i].en or s.send_out[j].en
  //     s.send_out[j].en = s.send_out[j].en and s.recv_opt.en
  // 
  //   s.send_out[0].msg = s.from_mem_rdata.msg
  //   s.to_mem_waddr.en = b1( 0 )
  //   s.to_mem_wdata.en = b1( 0 )
  //   if s.recv_opt.msg.ctrl == OPT_LD:
  //     s.recv_in[in0].rdy     = s.to_mem_raddr.rdy
  //     s.recv_in[in1].rdy     = s.from_mem_rdata.rdy
  //     s.to_mem_raddr.msg   = AddrType( s.recv_in[in0].msg.payload )
  //     s.to_mem_raddr.en    = s.recv_in[in0].en
  //     s.from_mem_rdata.rdy = s.send_out[0].rdy
  //     s.send_out[0].msg    = s.from_mem_rdata.msg
  //     s.send_out[0].en     = s.recv_opt.en
  //     s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_LD_CONST:
  //     for i in range( num_inports):
  //       s.recv_in[i].rdy = b1( 0 )
  //     s.recv_const.rdy     = s.to_mem_raddr.rdy
  //     s.to_mem_raddr.msg   = AddrType( s.recv_const.msg.payload )
  //     s.to_mem_raddr.en    = s.recv_const.en
  //     s.from_mem_rdata.rdy = s.send_out[0].rdy
  //     s.send_out[0].msg    = s.from_mem_rdata.msg
  //     s.send_out[0].en     = s.recv_opt.en
  //     # Const's predicate will always be true.
  //     s.send_out[0].msg.predicate = b1( 1 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_STR:
  //     s.send_out[0].en   = s.from_mem_rdata.en and s.recv_in[in0].en and s.recv_in[in1].en
  //     s.recv_in[in0].rdy   = s.to_mem_waddr.rdy
  //     s.recv_in[in1].rdy   = s.to_mem_wdata.rdy
  //     s.to_mem_waddr.msg = AddrType( s.recv_in[0].msg.payload )
  //     s.to_mem_waddr.en  = s.recv_in[in0].en
  //     s.to_mem_wdata.msg = s.recv_in[in1].msg
  //     s.to_mem_wdata.en  = s.recv_in[in1].en
  //     s.send_out[0].en   = b1( 0 )
  //     s.send_out[0].msg  = s.from_mem_rdata.msg
  //     s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                   s.recv_in[in1].msg.predicate
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 ) begin
      for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
        send_out__en[j] = recv_in__en[i] || send_out__en[j];
      send_out__en[j] = send_out__en[j] && recv_opt__en;
    end
    send_out__msg[0] = from_mem_rdata__msg;
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    if ( recv_opt__msg.ctrl == __const__OPT_LD ) begin
      recv_in__rdy[__tmpvar__comb_logic_in0] = to_mem_raddr__rdy;
      recv_in__rdy[__tmpvar__comb_logic_in1] = from_mem_rdata__rdy;
      to_mem_raddr__msg = 3'( recv_in__msg[__tmpvar__comb_logic_in0].payload );
      to_mem_raddr__en = recv_in__en[__tmpvar__comb_logic_in0];
      from_mem_rdata__rdy = send_out__rdy[0];
      send_out__msg[0] = from_mem_rdata__msg;
      send_out__en[0] = recv_opt__en;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_LD_CONST ) begin
      for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
        recv_in__rdy[i] = 1'd0;
      recv_const__rdy = to_mem_raddr__rdy;
      to_mem_raddr__msg = 3'( recv_const__msg.payload );
      to_mem_raddr__en = recv_const__en;
      from_mem_rdata__rdy = send_out__rdy[0];
      send_out__msg[0] = from_mem_rdata__msg;
      send_out__en[0] = recv_opt__en;
      send_out__msg[0].predicate = 1'd1;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_STR ) begin
      send_out__en[0] = from_mem_rdata__en && recv_in__en[__tmpvar__comb_logic_in0] && recv_in__en[__tmpvar__comb_logic_in1];
      recv_in__rdy[__tmpvar__comb_logic_in0] = to_mem_waddr__rdy;
      recv_in__rdy[__tmpvar__comb_logic_in1] = to_mem_wdata__rdy;
      to_mem_waddr__msg = 3'( recv_in__msg[0].payload );
      to_mem_waddr__en = recv_in__en[__tmpvar__comb_logic_in0];
      to_mem_wdata__msg = recv_in__msg[__tmpvar__comb_logic_in1];
      to_mem_wdata__en = recv_in__en[__tmpvar__comb_logic_in1];
      send_out__en[0] = 1'd0;
      send_out__msg[0] = from_mem_rdata__msg;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

endmodule


// PyMTL Component SelRTL Definition
// Full name: SelRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/single/SelRTL.py

module SelRTL__db8947ea533b8891
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam CGRAData_32_1_1 true = { 32'd1, 1'd1, 1'd0 };
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_SEL = 6'd27;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;
  logic [2:0] __tmpvar__comb_logic_in2 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/SelRTL.py:53
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register, Selector needs at least 3 inputs
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   in2 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[2] != FuInType( 0 ):
  //       in2 = s.recv_opt.msg.fu_in[2] - FuInType( 1 )
  //       s.recv_in[in2].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  //   if s.recv_opt.msg.ctrl == OPT_SEL:
  //     if s.recv_in[in0].msg.payload == s.true.payload:
  //       s.send_out[0].msg = s.recv_in[in1].msg
  //     else:
  //       s.send_out[0].msg = s.recv_in[in2].msg
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) or\
  //                            s.recv_in_count[in2] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.recv_in[in2].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    __tmpvar__comb_logic_in2 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[2] != 3'd0 ) begin
        __tmpvar__comb_logic_in2 = recv_opt__msg.fu_in[2] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in2] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_SEL ) begin
      if ( recv_in__msg[__tmpvar__comb_logic_in0].payload == true.payload ) begin
        send_out__msg[0] = recv_in__msg[__tmpvar__comb_logic_in1];
      end
      else
        send_out__msg[0] = recv_in__msg[__tmpvar__comb_logic_in2];
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in2] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in2] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/single/SelRTL.py:43
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

endmodule


// PyMTL Component VectorMulRTL Definition
// Full name: VectorMulRTL__bw_4__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulRTL.py

module VectorMulRTL__197a071796c128d3
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] recv_const__en,
  input logic [7:0] recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input logic [7:0] recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  output logic [0:0] send_out__en [0:1],
  output logic [7:0] send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1]
);
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_MUL = 6'd7;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulRTL.py:48
  // @s.update
  // def comb_logic():
  // 
  //   # Pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  // 
  //   if s.recv_opt.msg.ctrl == OPT_MUL:
  //     s.send_out[0].msg = s.recv_in[in0].msg * s.recv_in[in1].msg
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_MUL ) begin
      send_out__msg[0] = recv_in__msg[__tmpvar__comb_logic_in0] * recv_in__msg[__tmpvar__comb_logic_in1];
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulRTL.py:42
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component VectorMulComboRTL Definition
// Full name: VectorMulComboRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8__num_lanes_4__data_bandwidth_16
// At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulComboRTL.py

module VectorMulComboRTL__60fd794a47393cda
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [5:0] __const__OPT_VEC_MUL = 6'd55;
  localparam logic [31:0] __const__data_bandwidth_at_update_input_output = 32'd16;
  localparam logic [31:0] __const__sub_bw_at_update_input_output = 32'd4;
  localparam logic [31:0] __const__sub_bw_2_at_update_input_output = 32'd8;
  localparam logic [31:0] __const__sub_bw_3_at_update_input_output = 32'd12;
  localparam logic [31:0] __const__sub_bw_4_at_update_input_output = 32'd16;
  localparam logic [31:0] __const__num_lanes_at_update_input_output = 32'd4;
  localparam logic [5:0] __const__OPT_MUL = 6'd7;
  localparam logic [31:0] __const__num_outports_at_update_input_output = 32'd2;
  localparam logic [31:0] __const__num_lanes_at_update_signal = 32'd4;
  localparam logic [31:0] __const__num_lanes_at_update_opt = 32'd4;
  logic [15:0] temp_result [0:3] ;
  //-------------------------------------------------------------
  // Component Fu[0:3]
  //-------------------------------------------------------------

  logic [0:0] Fu__clk [0:3] ;
  logic [1:0] Fu__recv_in_count [0:3][0:3] ;
  logic [0:0] Fu__reset [0:3] ;
  logic [0:0] Fu__recv_const__en [0:3] ;
  logic [7:0] Fu__recv_const__msg [0:3] ;
  logic [0:0] Fu__recv_const__rdy [0:3] ;
  logic [0:0] Fu__recv_in__en [0:3][0:3] ;
  logic [7:0] Fu__recv_in__msg [0:3][0:3] ;
  logic [0:0] Fu__recv_in__rdy [0:3][0:3] ;
  logic [0:0] Fu__recv_opt__en [0:3] ;
  CGRAConfig_6_4_6_8 Fu__recv_opt__msg [0:3] ;
  logic [0:0] Fu__recv_opt__rdy [0:3] ;
  logic [0:0] Fu__send_out__en [0:3][0:1] ;
  logic [7:0] Fu__send_out__msg [0:3][0:1] ;
  logic [0:0] Fu__send_out__rdy [0:3][0:1] ;

  VectorMulRTL__197a071796c128d3 Fu__0
  (
    .clk( Fu__clk[0] ),
    .recv_in_count( Fu__recv_in_count[0] ),
    .reset( Fu__reset[0] ),
    .recv_const__en( Fu__recv_const__en[0] ),
    .recv_const__msg( Fu__recv_const__msg[0] ),
    .recv_const__rdy( Fu__recv_const__rdy[0] ),
    .recv_in__en( Fu__recv_in__en[0] ),
    .recv_in__msg( Fu__recv_in__msg[0] ),
    .recv_in__rdy( Fu__recv_in__rdy[0] ),
    .recv_opt__en( Fu__recv_opt__en[0] ),
    .recv_opt__msg( Fu__recv_opt__msg[0] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[0] ),
    .send_out__en( Fu__send_out__en[0] ),
    .send_out__msg( Fu__send_out__msg[0] ),
    .send_out__rdy( Fu__send_out__rdy[0] )
  );

  VectorMulRTL__197a071796c128d3 Fu__1
  (
    .clk( Fu__clk[1] ),
    .recv_in_count( Fu__recv_in_count[1] ),
    .reset( Fu__reset[1] ),
    .recv_const__en( Fu__recv_const__en[1] ),
    .recv_const__msg( Fu__recv_const__msg[1] ),
    .recv_const__rdy( Fu__recv_const__rdy[1] ),
    .recv_in__en( Fu__recv_in__en[1] ),
    .recv_in__msg( Fu__recv_in__msg[1] ),
    .recv_in__rdy( Fu__recv_in__rdy[1] ),
    .recv_opt__en( Fu__recv_opt__en[1] ),
    .recv_opt__msg( Fu__recv_opt__msg[1] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[1] ),
    .send_out__en( Fu__send_out__en[1] ),
    .send_out__msg( Fu__send_out__msg[1] ),
    .send_out__rdy( Fu__send_out__rdy[1] )
  );

  VectorMulRTL__197a071796c128d3 Fu__2
  (
    .clk( Fu__clk[2] ),
    .recv_in_count( Fu__recv_in_count[2] ),
    .reset( Fu__reset[2] ),
    .recv_const__en( Fu__recv_const__en[2] ),
    .recv_const__msg( Fu__recv_const__msg[2] ),
    .recv_const__rdy( Fu__recv_const__rdy[2] ),
    .recv_in__en( Fu__recv_in__en[2] ),
    .recv_in__msg( Fu__recv_in__msg[2] ),
    .recv_in__rdy( Fu__recv_in__rdy[2] ),
    .recv_opt__en( Fu__recv_opt__en[2] ),
    .recv_opt__msg( Fu__recv_opt__msg[2] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[2] ),
    .send_out__en( Fu__send_out__en[2] ),
    .send_out__msg( Fu__send_out__msg[2] ),
    .send_out__rdy( Fu__send_out__rdy[2] )
  );

  VectorMulRTL__197a071796c128d3 Fu__3
  (
    .clk( Fu__clk[3] ),
    .recv_in_count( Fu__recv_in_count[3] ),
    .reset( Fu__reset[3] ),
    .recv_const__en( Fu__recv_const__en[3] ),
    .recv_const__msg( Fu__recv_const__msg[3] ),
    .recv_const__rdy( Fu__recv_const__rdy[3] ),
    .recv_in__en( Fu__recv_in__en[3] ),
    .recv_in__msg( Fu__recv_in__msg[3] ),
    .recv_in__rdy( Fu__recv_in__rdy[3] ),
    .recv_opt__en( Fu__recv_opt__en[3] ),
    .recv_opt__msg( Fu__recv_opt__msg[3] ),
    .recv_opt__rdy( Fu__recv_opt__rdy[3] ),
    .send_out__en( Fu__send_out__en[3] ),
    .send_out__msg( Fu__send_out__msg[3] ),
    .send_out__rdy( Fu__send_out__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component Fu[0:3]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulComboRTL.py:64
  //   @s.update
  //   def update_input_output():
  // 
  //     s.send_out[0].en = s.recv_in[0].en and\
  //                        s.recv_in[1].en and\
  //                        s.recv_opt.en
  // 
  //     if s.recv_opt.msg.ctrl == OPT_VEC_MUL:
  // 
  //       s.send_out[0].msg.payload[0:data_bandwidth] = TempDataType( 0 )
  // 
  //       # Connection: split into vectorized FUs
  //       s.Fu[0].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[0:sub_bw]
  //       s.Fu[0].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[0:sub_bw]
  //       s.Fu[1].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[sub_bw:sub_bw_2]
  //       s.Fu[1].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[sub_bw:sub_bw_2]
  //       s.Fu[2].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[sub_bw_2:sub_bw_3]
  //       s.Fu[2].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[sub_bw_2:sub_bw_3]
  //       s.Fu[3].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[sub_bw_3:sub_bw_4]
  //       s.Fu[3].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[sub_bw_3:sub_bw_4]
  // 
  //       for i in range( num_lanes ):
  // 
  //         s.temp_result[i] = TempDataType( 0 )
  //         s.temp_result[i][0:sub_bw_2] = s.Fu[i].send_out[0].msg[0:sub_bw_2]
  // 
  //         s.send_out[0].msg.payload[0:data_bandwidth] = s.send_out[0].msg.payload[0:data_bandwidth] + (s.temp_result[i] << (sub_bw * i));
  //         # s.send_out[0].msg.payload[sub_bw*i:sub_bw*(i+1)] = s.Fu[i].send_out[0].msg[0:sub_bw];
  // 
  //     elif s.recv_opt.msg.ctrl == OPT_MUL: # with highest precision
  // 
  //       s.Fu[0].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[0:sub_bw]
  //       s.Fu[0].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[0:sub_bw]
  //       s.Fu[1].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[0:sub_bw]
  //       s.Fu[1].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[sub_bw:sub_bw_2] 
  //       s.Fu[2].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[sub_bw:sub_bw_2] 
  //       s.Fu[2].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[0:sub_bw]
  //       s.Fu[3].recv_in[0].msg[0:sub_bw] = s.recv_in[0].msg.payload[sub_bw:sub_bw_2] 
  //       s.Fu[3].recv_in[1].msg[0:sub_bw] = s.recv_in[1].msg.payload[sub_bw:sub_bw_2] 
  //   
  //       for i in range( num_lanes ):
  //         s.temp_result[i] = TempDataType( 0 )
  //         s.temp_result[i][0:sub_bw_2] = s.Fu[i].send_out[0].msg[0:sub_bw_2]
  // 
  //       s.send_out[0].msg.payload[0:data_bandwidth] = s.temp_result[0] + (s.temp_result[1] << sub_bw) + (s.temp_result[2] << sub_bw) + (s.temp_result[3] << (sub_bw*2))
  // 
  //     else:
  //       for j in range( num_outports ):
  //         s.send_out[j].en = b1( 0 )
  
  always_comb begin : update_input_output
    send_out__en[0] = recv_in__en[0] && recv_in__en[1] && recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_VEC_MUL ) begin
      send_out__msg[0].payload[15:0] = 16'd0;
      Fu__recv_in__msg[0][0][3:0] = recv_in__msg[0].payload[3:0];
      Fu__recv_in__msg[0][1][3:0] = recv_in__msg[1].payload[3:0];
      Fu__recv_in__msg[1][0][3:0] = recv_in__msg[0].payload[7:__const__sub_bw_at_update_input_output];
      Fu__recv_in__msg[1][1][3:0] = recv_in__msg[1].payload[7:__const__sub_bw_at_update_input_output];
      Fu__recv_in__msg[2][0][3:0] = recv_in__msg[0].payload[11:__const__sub_bw_2_at_update_input_output];
      Fu__recv_in__msg[2][1][3:0] = recv_in__msg[1].payload[11:__const__sub_bw_2_at_update_input_output];
      Fu__recv_in__msg[3][0][3:0] = recv_in__msg[0].payload[15:__const__sub_bw_3_at_update_input_output];
      Fu__recv_in__msg[3][1][3:0] = recv_in__msg[1].payload[15:__const__sub_bw_3_at_update_input_output];
      for ( int i = 0; i < __const__num_lanes_at_update_input_output; i += 1 ) begin
        temp_result[i] = 16'd0;
        temp_result[i][7:0] = Fu__send_out__msg[i][0][7:0];
        send_out__msg[0].payload[15:0] = send_out__msg[0].payload[15:0] + ( temp_result[i] << ( __const__sub_bw_at_update_input_output * i ) );
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_MUL ) begin
      Fu__recv_in__msg[0][0][3:0] = recv_in__msg[0].payload[3:0];
      Fu__recv_in__msg[0][1][3:0] = recv_in__msg[1].payload[3:0];
      Fu__recv_in__msg[1][0][3:0] = recv_in__msg[0].payload[3:0];
      Fu__recv_in__msg[1][1][3:0] = recv_in__msg[1].payload[7:__const__sub_bw_at_update_input_output];
      Fu__recv_in__msg[2][0][3:0] = recv_in__msg[0].payload[7:__const__sub_bw_at_update_input_output];
      Fu__recv_in__msg[2][1][3:0] = recv_in__msg[1].payload[3:0];
      Fu__recv_in__msg[3][0][3:0] = recv_in__msg[0].payload[7:__const__sub_bw_at_update_input_output];
      Fu__recv_in__msg[3][1][3:0] = recv_in__msg[1].payload[7:__const__sub_bw_at_update_input_output];
      for ( int i = 0; i < __const__num_lanes_at_update_input_output; i += 1 ) begin
        temp_result[i] = 16'd0;
        temp_result[i][7:0] = Fu__send_out__msg[i][0][7:0];
      end
      send_out__msg[0].payload[15:0] = ( ( temp_result[0] + ( temp_result[1] << __const__sub_bw_at_update_input_output ) ) + ( temp_result[2] << __const__sub_bw_at_update_input_output ) ) + ( temp_result[3] << ( __const__sub_bw_at_update_input_output * 2 ) );
    end
    else
      for ( int j = 0; j < __const__num_outports_at_update_input_output; j += 1 )
        send_out__en[j] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulComboRTL.py:152
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulComboRTL.py:135
  // @s.update
  // def update_opt():
  // 
  //   for i in range( num_lanes ):
  //     s.Fu[i].recv_opt.msg.fu_in[0] = FuInType(1)
  //     s.Fu[i].recv_opt.msg.fu_in[1] = FuInType(2)
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.recv_predicate.rdy = b1( 1 )
  // 
  //   if s.recv_opt.msg.ctrl == OPT_VEC_MUL or\
  //      s.recv_opt.msg.ctrl == OPT_MUL:
  //     for i in range( num_lanes ):
  //       s.Fu[i].recv_opt.msg.ctrl = OPT_MUL
  //     s.send_out[0].msg.predicate = s.recv_in[0].msg.predicate and s.recv_in[1].msg.predicate
  
  always_comb begin : update_opt
    for ( int i = 0; i < __const__num_lanes_at_update_opt; i += 1 ) begin
      Fu__recv_opt__msg[i].fu_in[0] = 3'd1;
      Fu__recv_opt__msg[i].fu_in[1] = 3'd2;
    end
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      recv_predicate__rdy = 1'd1;
    end
    if ( ( recv_opt__msg.ctrl == __const__OPT_VEC_MUL ) || ( recv_opt__msg.ctrl == __const__OPT_MUL ) ) begin
      for ( int i = 0; i < __const__num_lanes_at_update_opt; i += 1 )
        Fu__recv_opt__msg[i].ctrl = __const__OPT_MUL;
      send_out__msg[0].predicate = recv_in__msg[0].predicate && recv_in__msg[1].predicate;
    end
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/vector/VectorMulComboRTL.py:115
  // @s.update
  // def update_signal():
  //   s.recv_in[0].rdy  = s.send_out[0].rdy
  //   s.recv_in[1].rdy  = s.send_out[0].rdy
  // 
  //   for i in range( num_lanes ):
  //     s.Fu[i].recv_opt.en = s.recv_opt.en
  // 
  //     # Note that the predication for a combined FU should be identical/shareable,
  //     # which means the computation in different basic block cannot be combined.
  //     # s.Fu[i].recv_opt.msg.predicate = s.recv_opt.msg.predicate
  // 
  //     # Connect count
  //     s.Fu[i].recv_in_count[0] = s.recv_in_count[0]
  //     s.Fu[i].recv_in_count[1] = s.recv_in_count[1]
  // 
  //   s.recv_opt.rdy    = s.send_out[0].rdy
  
  always_comb begin : update_signal
    recv_in__rdy[0] = send_out__rdy[0];
    recv_in__rdy[1] = send_out__rdy[0];
    for ( int i = 0; i < __const__num_lanes_at_update_signal; i += 1 ) begin
      Fu__recv_opt__en[i] = recv_opt__en;
      Fu__recv_in_count[i][0] = recv_in_count[0];
      Fu__recv_in_count[i][1] = recv_in_count[1];
    end
    recv_opt__rdy = send_out__rdy[0];
  end

  assign Fu__clk[0] = clk;
  assign Fu__reset[0] = reset;
  assign Fu__clk[1] = clk;
  assign Fu__reset[1] = reset;
  assign Fu__clk[2] = clk;
  assign Fu__reset[2] = reset;
  assign Fu__clk[3] = clk;
  assign Fu__reset[3] = reset;

endmodule


// PyMTL Component FlexibleFuRTL Definition
// Full name: FlexibleFuRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__num_inports_4__num_outports_2__data_mem_size_8__FuList_[<class 'vrsa.fu.single.AdderRTL.AdderRTL'>, <class 'vrsa.fu.single.MulRTL.MulRTL'>, <class 'vrsa.fu.single.LogicRTL.LogicRTL'>, <class 'vrsa.fu.single.ShifterRTL.ShifterRTL'>, <class 'vrsa.fu.single.PhiRTL.PhiRTL'>, <class 'vrsa.fu.single.CompRTL.CompRTL'>, <class 'vrsa.fu.single.BranchRTL.BranchRTL'>, <class 'vrsa.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'vrsa.fu.single.SelRTL.SelRTL'>, <class 'vrsa.fu.vector.VectorMulComboRTL.VectorMulComboRTL'>]
// At /home/cheng/workspace/projects/cgra/vrsa/fu/flexible/FlexibleFuRTL.py

module FlexibleFuRTL__af19c74e4933e98f
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en [0:9],
  input CGRAData_32_1_1 from_mem_rdata__msg [0:9],
  output logic [0:0] from_mem_rdata__rdy [0:9],
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en [0:9],
  output logic [2:0] to_mem_raddr__msg [0:9],
  input logic [0:0] to_mem_raddr__rdy [0:9],
  output logic [0:0] to_mem_waddr__en [0:9],
  output logic [2:0] to_mem_waddr__msg [0:9],
  input logic [0:0] to_mem_waddr__rdy [0:9],
  output logic [0:0] to_mem_wdata__en [0:9],
  output CGRAData_32_1_1 to_mem_wdata__msg [0:9],
  input logic [0:0] to_mem_wdata__rdy [0:9]
);
  localparam logic [31:0] fu_list_size = 32'd10;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  //-------------------------------------------------------------
  // Component fu[0:9]
  //-------------------------------------------------------------

  logic [0:0] fu__clk [0:9] ;
  logic [1:0] fu__recv_in_count [0:9][0:3] ;
  logic [0:0] fu__reset [0:9] ;
  logic [0:0] fu__from_mem_rdata__en [0:9] ;
  CGRAData_32_1_1 fu__from_mem_rdata__msg [0:9] ;
  logic [0:0] fu__from_mem_rdata__rdy [0:9] ;
  logic [0:0] fu__recv_const__en [0:9] ;
  CGRAData_32_1_1 fu__recv_const__msg [0:9] ;
  logic [0:0] fu__recv_const__rdy [0:9] ;
  logic [0:0] fu__recv_in__en [0:9][0:3] ;
  CGRAData_32_1_1 fu__recv_in__msg [0:9][0:3] ;
  logic [0:0] fu__recv_in__rdy [0:9][0:3] ;
  logic [0:0] fu__recv_opt__en [0:9] ;
  CGRAConfig_6_4_6_8 fu__recv_opt__msg [0:9] ;
  logic [0:0] fu__recv_opt__rdy [0:9] ;
  logic [0:0] fu__recv_predicate__en [0:9] ;
  CGRAData_1_1 fu__recv_predicate__msg [0:9] ;
  logic [0:0] fu__recv_predicate__rdy [0:9] ;
  logic [0:0] fu__send_out__en [0:9][0:1] ;
  CGRAData_32_1_1 fu__send_out__msg [0:9][0:1] ;
  logic [0:0] fu__send_out__rdy [0:9][0:1] ;
  logic [0:0] fu__to_mem_raddr__en [0:9] ;
  logic [2:0] fu__to_mem_raddr__msg [0:9] ;
  logic [0:0] fu__to_mem_raddr__rdy [0:9] ;
  logic [0:0] fu__to_mem_waddr__en [0:9] ;
  logic [2:0] fu__to_mem_waddr__msg [0:9] ;
  logic [0:0] fu__to_mem_waddr__rdy [0:9] ;
  logic [0:0] fu__to_mem_wdata__en [0:9] ;
  CGRAData_32_1_1 fu__to_mem_wdata__msg [0:9] ;
  logic [0:0] fu__to_mem_wdata__rdy [0:9] ;

  AdderRTL__db8947ea533b8891 fu__0
  (
    .clk( fu__clk[0] ),
    .recv_in_count( fu__recv_in_count[0] ),
    .reset( fu__reset[0] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[0] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[0] ),
    .recv_const__en( fu__recv_const__en[0] ),
    .recv_const__msg( fu__recv_const__msg[0] ),
    .recv_const__rdy( fu__recv_const__rdy[0] ),
    .recv_in__en( fu__recv_in__en[0] ),
    .recv_in__msg( fu__recv_in__msg[0] ),
    .recv_in__rdy( fu__recv_in__rdy[0] ),
    .recv_opt__en( fu__recv_opt__en[0] ),
    .recv_opt__msg( fu__recv_opt__msg[0] ),
    .recv_opt__rdy( fu__recv_opt__rdy[0] ),
    .recv_predicate__en( fu__recv_predicate__en[0] ),
    .recv_predicate__msg( fu__recv_predicate__msg[0] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[0] ),
    .send_out__en( fu__send_out__en[0] ),
    .send_out__msg( fu__send_out__msg[0] ),
    .send_out__rdy( fu__send_out__rdy[0] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[0] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[0] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[0] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[0] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[0] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[0] )
  );

  MulRTL__db8947ea533b8891 fu__1
  (
    .clk( fu__clk[1] ),
    .recv_in_count( fu__recv_in_count[1] ),
    .reset( fu__reset[1] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[1] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[1] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[1] ),
    .recv_const__en( fu__recv_const__en[1] ),
    .recv_const__msg( fu__recv_const__msg[1] ),
    .recv_const__rdy( fu__recv_const__rdy[1] ),
    .recv_in__en( fu__recv_in__en[1] ),
    .recv_in__msg( fu__recv_in__msg[1] ),
    .recv_in__rdy( fu__recv_in__rdy[1] ),
    .recv_opt__en( fu__recv_opt__en[1] ),
    .recv_opt__msg( fu__recv_opt__msg[1] ),
    .recv_opt__rdy( fu__recv_opt__rdy[1] ),
    .recv_predicate__en( fu__recv_predicate__en[1] ),
    .recv_predicate__msg( fu__recv_predicate__msg[1] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[1] ),
    .send_out__en( fu__send_out__en[1] ),
    .send_out__msg( fu__send_out__msg[1] ),
    .send_out__rdy( fu__send_out__rdy[1] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[1] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[1] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[1] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[1] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[1] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[1] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[1] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[1] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[1] )
  );

  LogicRTL__db8947ea533b8891 fu__2
  (
    .clk( fu__clk[2] ),
    .recv_in_count( fu__recv_in_count[2] ),
    .reset( fu__reset[2] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[2] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[2] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[2] ),
    .recv_const__en( fu__recv_const__en[2] ),
    .recv_const__msg( fu__recv_const__msg[2] ),
    .recv_const__rdy( fu__recv_const__rdy[2] ),
    .recv_in__en( fu__recv_in__en[2] ),
    .recv_in__msg( fu__recv_in__msg[2] ),
    .recv_in__rdy( fu__recv_in__rdy[2] ),
    .recv_opt__en( fu__recv_opt__en[2] ),
    .recv_opt__msg( fu__recv_opt__msg[2] ),
    .recv_opt__rdy( fu__recv_opt__rdy[2] ),
    .recv_predicate__en( fu__recv_predicate__en[2] ),
    .recv_predicate__msg( fu__recv_predicate__msg[2] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[2] ),
    .send_out__en( fu__send_out__en[2] ),
    .send_out__msg( fu__send_out__msg[2] ),
    .send_out__rdy( fu__send_out__rdy[2] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[2] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[2] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[2] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[2] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[2] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[2] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[2] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[2] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[2] )
  );

  ShifterRTL__db8947ea533b8891 fu__3
  (
    .clk( fu__clk[3] ),
    .recv_in_count( fu__recv_in_count[3] ),
    .reset( fu__reset[3] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[3] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[3] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[3] ),
    .recv_const__en( fu__recv_const__en[3] ),
    .recv_const__msg( fu__recv_const__msg[3] ),
    .recv_const__rdy( fu__recv_const__rdy[3] ),
    .recv_in__en( fu__recv_in__en[3] ),
    .recv_in__msg( fu__recv_in__msg[3] ),
    .recv_in__rdy( fu__recv_in__rdy[3] ),
    .recv_opt__en( fu__recv_opt__en[3] ),
    .recv_opt__msg( fu__recv_opt__msg[3] ),
    .recv_opt__rdy( fu__recv_opt__rdy[3] ),
    .recv_predicate__en( fu__recv_predicate__en[3] ),
    .recv_predicate__msg( fu__recv_predicate__msg[3] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[3] ),
    .send_out__en( fu__send_out__en[3] ),
    .send_out__msg( fu__send_out__msg[3] ),
    .send_out__rdy( fu__send_out__rdy[3] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[3] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[3] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[3] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[3] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[3] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[3] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[3] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[3] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[3] )
  );

  PhiRTL__db8947ea533b8891 fu__4
  (
    .clk( fu__clk[4] ),
    .recv_in_count( fu__recv_in_count[4] ),
    .reset( fu__reset[4] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[4] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[4] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[4] ),
    .recv_const__en( fu__recv_const__en[4] ),
    .recv_const__msg( fu__recv_const__msg[4] ),
    .recv_const__rdy( fu__recv_const__rdy[4] ),
    .recv_in__en( fu__recv_in__en[4] ),
    .recv_in__msg( fu__recv_in__msg[4] ),
    .recv_in__rdy( fu__recv_in__rdy[4] ),
    .recv_opt__en( fu__recv_opt__en[4] ),
    .recv_opt__msg( fu__recv_opt__msg[4] ),
    .recv_opt__rdy( fu__recv_opt__rdy[4] ),
    .recv_predicate__en( fu__recv_predicate__en[4] ),
    .recv_predicate__msg( fu__recv_predicate__msg[4] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[4] ),
    .send_out__en( fu__send_out__en[4] ),
    .send_out__msg( fu__send_out__msg[4] ),
    .send_out__rdy( fu__send_out__rdy[4] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[4] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[4] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[4] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[4] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[4] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[4] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[4] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[4] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[4] )
  );

  CompRTL__db8947ea533b8891 fu__5
  (
    .clk( fu__clk[5] ),
    .recv_in_count( fu__recv_in_count[5] ),
    .reset( fu__reset[5] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[5] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[5] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[5] ),
    .recv_const__en( fu__recv_const__en[5] ),
    .recv_const__msg( fu__recv_const__msg[5] ),
    .recv_const__rdy( fu__recv_const__rdy[5] ),
    .recv_in__en( fu__recv_in__en[5] ),
    .recv_in__msg( fu__recv_in__msg[5] ),
    .recv_in__rdy( fu__recv_in__rdy[5] ),
    .recv_opt__en( fu__recv_opt__en[5] ),
    .recv_opt__msg( fu__recv_opt__msg[5] ),
    .recv_opt__rdy( fu__recv_opt__rdy[5] ),
    .recv_predicate__en( fu__recv_predicate__en[5] ),
    .recv_predicate__msg( fu__recv_predicate__msg[5] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[5] ),
    .send_out__en( fu__send_out__en[5] ),
    .send_out__msg( fu__send_out__msg[5] ),
    .send_out__rdy( fu__send_out__rdy[5] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[5] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[5] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[5] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[5] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[5] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[5] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[5] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[5] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[5] )
  );

  BranchRTL__db8947ea533b8891 fu__6
  (
    .clk( fu__clk[6] ),
    .recv_in_count( fu__recv_in_count[6] ),
    .reset( fu__reset[6] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[6] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[6] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[6] ),
    .recv_const__en( fu__recv_const__en[6] ),
    .recv_const__msg( fu__recv_const__msg[6] ),
    .recv_const__rdy( fu__recv_const__rdy[6] ),
    .recv_in__en( fu__recv_in__en[6] ),
    .recv_in__msg( fu__recv_in__msg[6] ),
    .recv_in__rdy( fu__recv_in__rdy[6] ),
    .recv_opt__en( fu__recv_opt__en[6] ),
    .recv_opt__msg( fu__recv_opt__msg[6] ),
    .recv_opt__rdy( fu__recv_opt__rdy[6] ),
    .recv_predicate__en( fu__recv_predicate__en[6] ),
    .recv_predicate__msg( fu__recv_predicate__msg[6] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[6] ),
    .send_out__en( fu__send_out__en[6] ),
    .send_out__msg( fu__send_out__msg[6] ),
    .send_out__rdy( fu__send_out__rdy[6] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[6] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[6] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[6] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[6] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[6] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[6] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[6] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[6] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[6] )
  );

  MemUnitRTL__db8947ea533b8891 fu__7
  (
    .clk( fu__clk[7] ),
    .recv_in_count( fu__recv_in_count[7] ),
    .reset( fu__reset[7] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[7] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[7] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[7] ),
    .recv_const__en( fu__recv_const__en[7] ),
    .recv_const__msg( fu__recv_const__msg[7] ),
    .recv_const__rdy( fu__recv_const__rdy[7] ),
    .recv_in__en( fu__recv_in__en[7] ),
    .recv_in__msg( fu__recv_in__msg[7] ),
    .recv_in__rdy( fu__recv_in__rdy[7] ),
    .recv_opt__en( fu__recv_opt__en[7] ),
    .recv_opt__msg( fu__recv_opt__msg[7] ),
    .recv_opt__rdy( fu__recv_opt__rdy[7] ),
    .recv_predicate__en( fu__recv_predicate__en[7] ),
    .recv_predicate__msg( fu__recv_predicate__msg[7] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[7] ),
    .send_out__en( fu__send_out__en[7] ),
    .send_out__msg( fu__send_out__msg[7] ),
    .send_out__rdy( fu__send_out__rdy[7] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[7] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[7] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[7] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[7] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[7] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[7] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[7] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[7] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[7] )
  );

  SelRTL__db8947ea533b8891 fu__8
  (
    .clk( fu__clk[8] ),
    .recv_in_count( fu__recv_in_count[8] ),
    .reset( fu__reset[8] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[8] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[8] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[8] ),
    .recv_const__en( fu__recv_const__en[8] ),
    .recv_const__msg( fu__recv_const__msg[8] ),
    .recv_const__rdy( fu__recv_const__rdy[8] ),
    .recv_in__en( fu__recv_in__en[8] ),
    .recv_in__msg( fu__recv_in__msg[8] ),
    .recv_in__rdy( fu__recv_in__rdy[8] ),
    .recv_opt__en( fu__recv_opt__en[8] ),
    .recv_opt__msg( fu__recv_opt__msg[8] ),
    .recv_opt__rdy( fu__recv_opt__rdy[8] ),
    .recv_predicate__en( fu__recv_predicate__en[8] ),
    .recv_predicate__msg( fu__recv_predicate__msg[8] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[8] ),
    .send_out__en( fu__send_out__en[8] ),
    .send_out__msg( fu__send_out__msg[8] ),
    .send_out__rdy( fu__send_out__rdy[8] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[8] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[8] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[8] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[8] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[8] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[8] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[8] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[8] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[8] )
  );

  VectorMulComboRTL__60fd794a47393cda fu__9
  (
    .clk( fu__clk[9] ),
    .recv_in_count( fu__recv_in_count[9] ),
    .reset( fu__reset[9] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[9] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[9] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[9] ),
    .recv_const__en( fu__recv_const__en[9] ),
    .recv_const__msg( fu__recv_const__msg[9] ),
    .recv_const__rdy( fu__recv_const__rdy[9] ),
    .recv_in__en( fu__recv_in__en[9] ),
    .recv_in__msg( fu__recv_in__msg[9] ),
    .recv_in__rdy( fu__recv_in__rdy[9] ),
    .recv_opt__en( fu__recv_opt__en[9] ),
    .recv_opt__msg( fu__recv_opt__msg[9] ),
    .recv_opt__rdy( fu__recv_opt__rdy[9] ),
    .recv_predicate__en( fu__recv_predicate__en[9] ),
    .recv_predicate__msg( fu__recv_predicate__msg[9] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[9] ),
    .send_out__en( fu__send_out__en[9] ),
    .send_out__msg( fu__send_out__msg[9] ),
    .send_out__rdy( fu__send_out__rdy[9] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[9] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[9] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[9] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[9] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[9] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[9] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[9] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[9] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[9] )
  );

  //-------------------------------------------------------------
  // End of component fu[0:9]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/fu/flexible/FlexibleFuRTL.py:53
  // @s.update
  // def comb_logic():
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en  = b1( 0 )
  // 
  //   for i in range( s.fu_list_size ):
  // 
  //     # const connection
  //     s.fu[i].recv_const.msg = s.recv_const.msg
  //     s.fu[i].recv_const.en  = s.recv_const.en
  //     s.recv_const.rdy       = s.recv_const.rdy or s.fu[i].recv_const.rdy
  // 
  //     for j in range( num_inports):
  //       s.fu[i].recv_in_count[j] = s.recv_in_count[j]
  // 
  //     # opt connection
  //     s.fu[i].recv_opt.msg = s.recv_opt.msg
  //     s.fu[i].recv_opt.en  = s.recv_opt.en
  //     s.recv_opt.rdy       = s.fu[i].recv_opt.rdy or s.recv_opt.rdy
  // 
  //     # Note that the predication for a combined FU should be identical/shareable,
  //     # which means the computation in different basic block cannot be combined.
  //     s.fu[i].recv_opt.msg.predicate = s.recv_opt.msg.predicate
  //     s.fu[i].recv_predicate.en      = s.recv_predicate.en
  //     s.recv_predicate.rdy           = s.fu[i].recv_predicate.rdy or s.recv_predicate.rdy
  //     s.fu[i].recv_predicate.msg     = s.recv_predicate.msg
  // 
  //     # send_out connection
  //     for j in range( num_outports ):
  //       if s.fu[i].send_out[j].en:
  //         s.send_out[j].msg     = s.fu[i].send_out[j].msg
  //         s.send_out[j].en      = s.fu[i].send_out[j].en
  //       s.fu[i].send_out[j].rdy = s.send_out[j].rdy
  // 
  // 
  //   for j in range( num_inports ):
  //     s.recv_in[j].rdy = b1( 0 )
  // 
  //   for i in range( s.fu_list_size ):
  //     # recv_in connection
  //     for j in range( num_inports ):
  //       s.fu[i].recv_in[j].msg = s.recv_in[j].msg
  //       s.fu[i].recv_in[j].en  = s.recv_in[j].en
  //       s.recv_in[j].rdy       = s.fu[i].recv_in[j].rdy or s.recv_in[j].rdy
  
  always_comb begin : comb_logic
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = 1'd0;
    for ( int i = 0; i < fu_list_size; i += 1 ) begin
      fu__recv_const__msg[i] = recv_const__msg;
      fu__recv_const__en[i] = recv_const__en;
      recv_const__rdy = recv_const__rdy || fu__recv_const__rdy[i];
      for ( int j = 0; j < __const__num_inports_at_comb_logic; j += 1 )
        fu__recv_in_count[i][j] = recv_in_count[j];
      fu__recv_opt__msg[i] = recv_opt__msg;
      fu__recv_opt__en[i] = recv_opt__en;
      recv_opt__rdy = fu__recv_opt__rdy[i] || recv_opt__rdy;
      fu__recv_opt__msg[i].predicate = recv_opt__msg.predicate;
      fu__recv_predicate__en[i] = recv_predicate__en;
      recv_predicate__rdy = fu__recv_predicate__rdy[i] || recv_predicate__rdy;
      fu__recv_predicate__msg[i] = recv_predicate__msg;
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 ) begin
        if ( fu__send_out__en[i][j] ) begin
          send_out__msg[j] = fu__send_out__msg[i][j];
          send_out__en[j] = fu__send_out__en[i][j];
        end
        fu__send_out__rdy[i][j] = send_out__rdy[j];
      end
    end
    for ( int j = 0; j < __const__num_inports_at_comb_logic; j += 1 )
      recv_in__rdy[j] = 1'd0;
    for ( int i = 0; i < fu_list_size; i += 1 )
      for ( int j = 0; j < __const__num_inports_at_comb_logic; j += 1 ) begin
        fu__recv_in__msg[i][j] = recv_in__msg[j];
        fu__recv_in__en[i][j] = recv_in__en[j];
        recv_in__rdy[j] = fu__recv_in__rdy[i][j] || recv_in__rdy[j];
      end
  end

  assign fu__clk[0] = clk;
  assign fu__reset[0] = reset;
  assign fu__clk[1] = clk;
  assign fu__reset[1] = reset;
  assign fu__clk[2] = clk;
  assign fu__reset[2] = reset;
  assign fu__clk[3] = clk;
  assign fu__reset[3] = reset;
  assign fu__clk[4] = clk;
  assign fu__reset[4] = reset;
  assign fu__clk[5] = clk;
  assign fu__reset[5] = reset;
  assign fu__clk[6] = clk;
  assign fu__reset[6] = reset;
  assign fu__clk[7] = clk;
  assign fu__reset[7] = reset;
  assign fu__clk[8] = clk;
  assign fu__reset[8] = reset;
  assign fu__clk[9] = clk;
  assign fu__reset[9] = reset;
  assign to_mem_raddr__en[0] = fu__to_mem_raddr__en[0];
  assign to_mem_raddr__msg[0] = fu__to_mem_raddr__msg[0];
  assign fu__to_mem_raddr__rdy[0] = to_mem_raddr__rdy[0];
  assign fu__from_mem_rdata__en[0] = from_mem_rdata__en[0];
  assign fu__from_mem_rdata__msg[0] = from_mem_rdata__msg[0];
  assign from_mem_rdata__rdy[0] = fu__from_mem_rdata__rdy[0];
  assign to_mem_waddr__en[0] = fu__to_mem_waddr__en[0];
  assign to_mem_waddr__msg[0] = fu__to_mem_waddr__msg[0];
  assign fu__to_mem_waddr__rdy[0] = to_mem_waddr__rdy[0];
  assign to_mem_wdata__en[0] = fu__to_mem_wdata__en[0];
  assign to_mem_wdata__msg[0] = fu__to_mem_wdata__msg[0];
  assign fu__to_mem_wdata__rdy[0] = to_mem_wdata__rdy[0];
  assign to_mem_raddr__en[1] = fu__to_mem_raddr__en[1];
  assign to_mem_raddr__msg[1] = fu__to_mem_raddr__msg[1];
  assign fu__to_mem_raddr__rdy[1] = to_mem_raddr__rdy[1];
  assign fu__from_mem_rdata__en[1] = from_mem_rdata__en[1];
  assign fu__from_mem_rdata__msg[1] = from_mem_rdata__msg[1];
  assign from_mem_rdata__rdy[1] = fu__from_mem_rdata__rdy[1];
  assign to_mem_waddr__en[1] = fu__to_mem_waddr__en[1];
  assign to_mem_waddr__msg[1] = fu__to_mem_waddr__msg[1];
  assign fu__to_mem_waddr__rdy[1] = to_mem_waddr__rdy[1];
  assign to_mem_wdata__en[1] = fu__to_mem_wdata__en[1];
  assign to_mem_wdata__msg[1] = fu__to_mem_wdata__msg[1];
  assign fu__to_mem_wdata__rdy[1] = to_mem_wdata__rdy[1];
  assign to_mem_raddr__en[2] = fu__to_mem_raddr__en[2];
  assign to_mem_raddr__msg[2] = fu__to_mem_raddr__msg[2];
  assign fu__to_mem_raddr__rdy[2] = to_mem_raddr__rdy[2];
  assign fu__from_mem_rdata__en[2] = from_mem_rdata__en[2];
  assign fu__from_mem_rdata__msg[2] = from_mem_rdata__msg[2];
  assign from_mem_rdata__rdy[2] = fu__from_mem_rdata__rdy[2];
  assign to_mem_waddr__en[2] = fu__to_mem_waddr__en[2];
  assign to_mem_waddr__msg[2] = fu__to_mem_waddr__msg[2];
  assign fu__to_mem_waddr__rdy[2] = to_mem_waddr__rdy[2];
  assign to_mem_wdata__en[2] = fu__to_mem_wdata__en[2];
  assign to_mem_wdata__msg[2] = fu__to_mem_wdata__msg[2];
  assign fu__to_mem_wdata__rdy[2] = to_mem_wdata__rdy[2];
  assign to_mem_raddr__en[3] = fu__to_mem_raddr__en[3];
  assign to_mem_raddr__msg[3] = fu__to_mem_raddr__msg[3];
  assign fu__to_mem_raddr__rdy[3] = to_mem_raddr__rdy[3];
  assign fu__from_mem_rdata__en[3] = from_mem_rdata__en[3];
  assign fu__from_mem_rdata__msg[3] = from_mem_rdata__msg[3];
  assign from_mem_rdata__rdy[3] = fu__from_mem_rdata__rdy[3];
  assign to_mem_waddr__en[3] = fu__to_mem_waddr__en[3];
  assign to_mem_waddr__msg[3] = fu__to_mem_waddr__msg[3];
  assign fu__to_mem_waddr__rdy[3] = to_mem_waddr__rdy[3];
  assign to_mem_wdata__en[3] = fu__to_mem_wdata__en[3];
  assign to_mem_wdata__msg[3] = fu__to_mem_wdata__msg[3];
  assign fu__to_mem_wdata__rdy[3] = to_mem_wdata__rdy[3];
  assign to_mem_raddr__en[4] = fu__to_mem_raddr__en[4];
  assign to_mem_raddr__msg[4] = fu__to_mem_raddr__msg[4];
  assign fu__to_mem_raddr__rdy[4] = to_mem_raddr__rdy[4];
  assign fu__from_mem_rdata__en[4] = from_mem_rdata__en[4];
  assign fu__from_mem_rdata__msg[4] = from_mem_rdata__msg[4];
  assign from_mem_rdata__rdy[4] = fu__from_mem_rdata__rdy[4];
  assign to_mem_waddr__en[4] = fu__to_mem_waddr__en[4];
  assign to_mem_waddr__msg[4] = fu__to_mem_waddr__msg[4];
  assign fu__to_mem_waddr__rdy[4] = to_mem_waddr__rdy[4];
  assign to_mem_wdata__en[4] = fu__to_mem_wdata__en[4];
  assign to_mem_wdata__msg[4] = fu__to_mem_wdata__msg[4];
  assign fu__to_mem_wdata__rdy[4] = to_mem_wdata__rdy[4];
  assign to_mem_raddr__en[5] = fu__to_mem_raddr__en[5];
  assign to_mem_raddr__msg[5] = fu__to_mem_raddr__msg[5];
  assign fu__to_mem_raddr__rdy[5] = to_mem_raddr__rdy[5];
  assign fu__from_mem_rdata__en[5] = from_mem_rdata__en[5];
  assign fu__from_mem_rdata__msg[5] = from_mem_rdata__msg[5];
  assign from_mem_rdata__rdy[5] = fu__from_mem_rdata__rdy[5];
  assign to_mem_waddr__en[5] = fu__to_mem_waddr__en[5];
  assign to_mem_waddr__msg[5] = fu__to_mem_waddr__msg[5];
  assign fu__to_mem_waddr__rdy[5] = to_mem_waddr__rdy[5];
  assign to_mem_wdata__en[5] = fu__to_mem_wdata__en[5];
  assign to_mem_wdata__msg[5] = fu__to_mem_wdata__msg[5];
  assign fu__to_mem_wdata__rdy[5] = to_mem_wdata__rdy[5];
  assign to_mem_raddr__en[6] = fu__to_mem_raddr__en[6];
  assign to_mem_raddr__msg[6] = fu__to_mem_raddr__msg[6];
  assign fu__to_mem_raddr__rdy[6] = to_mem_raddr__rdy[6];
  assign fu__from_mem_rdata__en[6] = from_mem_rdata__en[6];
  assign fu__from_mem_rdata__msg[6] = from_mem_rdata__msg[6];
  assign from_mem_rdata__rdy[6] = fu__from_mem_rdata__rdy[6];
  assign to_mem_waddr__en[6] = fu__to_mem_waddr__en[6];
  assign to_mem_waddr__msg[6] = fu__to_mem_waddr__msg[6];
  assign fu__to_mem_waddr__rdy[6] = to_mem_waddr__rdy[6];
  assign to_mem_wdata__en[6] = fu__to_mem_wdata__en[6];
  assign to_mem_wdata__msg[6] = fu__to_mem_wdata__msg[6];
  assign fu__to_mem_wdata__rdy[6] = to_mem_wdata__rdy[6];
  assign to_mem_raddr__en[7] = fu__to_mem_raddr__en[7];
  assign to_mem_raddr__msg[7] = fu__to_mem_raddr__msg[7];
  assign fu__to_mem_raddr__rdy[7] = to_mem_raddr__rdy[7];
  assign fu__from_mem_rdata__en[7] = from_mem_rdata__en[7];
  assign fu__from_mem_rdata__msg[7] = from_mem_rdata__msg[7];
  assign from_mem_rdata__rdy[7] = fu__from_mem_rdata__rdy[7];
  assign to_mem_waddr__en[7] = fu__to_mem_waddr__en[7];
  assign to_mem_waddr__msg[7] = fu__to_mem_waddr__msg[7];
  assign fu__to_mem_waddr__rdy[7] = to_mem_waddr__rdy[7];
  assign to_mem_wdata__en[7] = fu__to_mem_wdata__en[7];
  assign to_mem_wdata__msg[7] = fu__to_mem_wdata__msg[7];
  assign fu__to_mem_wdata__rdy[7] = to_mem_wdata__rdy[7];
  assign to_mem_raddr__en[8] = fu__to_mem_raddr__en[8];
  assign to_mem_raddr__msg[8] = fu__to_mem_raddr__msg[8];
  assign fu__to_mem_raddr__rdy[8] = to_mem_raddr__rdy[8];
  assign fu__from_mem_rdata__en[8] = from_mem_rdata__en[8];
  assign fu__from_mem_rdata__msg[8] = from_mem_rdata__msg[8];
  assign from_mem_rdata__rdy[8] = fu__from_mem_rdata__rdy[8];
  assign to_mem_waddr__en[8] = fu__to_mem_waddr__en[8];
  assign to_mem_waddr__msg[8] = fu__to_mem_waddr__msg[8];
  assign fu__to_mem_waddr__rdy[8] = to_mem_waddr__rdy[8];
  assign to_mem_wdata__en[8] = fu__to_mem_wdata__en[8];
  assign to_mem_wdata__msg[8] = fu__to_mem_wdata__msg[8];
  assign fu__to_mem_wdata__rdy[8] = to_mem_wdata__rdy[8];
  assign to_mem_raddr__en[9] = fu__to_mem_raddr__en[9];
  assign to_mem_raddr__msg[9] = fu__to_mem_raddr__msg[9];
  assign fu__to_mem_raddr__rdy[9] = to_mem_raddr__rdy[9];
  assign fu__from_mem_rdata__en[9] = from_mem_rdata__en[9];
  assign fu__from_mem_rdata__msg[9] = from_mem_rdata__msg[9];
  assign from_mem_rdata__rdy[9] = fu__from_mem_rdata__rdy[9];
  assign to_mem_waddr__en[9] = fu__to_mem_waddr__en[9];
  assign to_mem_waddr__msg[9] = fu__to_mem_waddr__msg[9];
  assign fu__to_mem_waddr__rdy[9] = to_mem_waddr__rdy[9];
  assign to_mem_wdata__en[9] = fu__to_mem_wdata__en[9];
  assign to_mem_wdata__msg[9] = fu__to_mem_wdata__msg[9];
  assign fu__to_mem_wdata__rdy[9] = to_mem_wdata__rdy[9];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAData_1_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__b2651f5e70154f41
(
  input logic [0:0] clk,
  input logic [0:0] raddr [0:0],
  output CGRAData_1_1 rdata [0:0],
  input logic [0:0] reset,
  input logic [0:0] waddr [0:0],
  input CGRAData_1_1 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAData_1_1 regs [0:1] ;

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueDpathRTL__EntryType_CGRAData_1_1__num_entries_2
(
  input logic [0:0] clk,
  output CGRAData_1_1 deq_ret,
  input CGRAData_1_1 enq_msg,
  input logic [0:0] raddr,
  input logic [0:0] reset,
  input logic [0:0] waddr,
  input logic [0:0] wen
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk ;
  logic [0:0] queue__raddr [0:0] ;
  CGRAData_1_1 queue__rdata [0:0] ;
  logic [0:0] queue__reset ;
  logic [0:0] queue__waddr [0:0] ;
  CGRAData_1_1 queue__wdata [0:0] ;
  logic [0:0] queue__wen [0:0] ;

  RegisterFile__b2651f5e70154f41 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// At /home/cheng/workspace/projects/cgra/venv/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueRTL__EntryType_CGRAData_1_1__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] reset,
  input logic [0:0] deq__en,
  output logic [0:0] deq__rdy,
  output CGRAData_1_1 deq__ret,
  input logic [0:0] enq__en,
  input CGRAData_1_1 enq__msg,
  output logic [0:0] enq__rdy
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk ;
  logic [1:0] ctrl__count ;
  logic [0:0] ctrl__deq_en ;
  logic [0:0] ctrl__deq_rdy ;
  logic [0:0] ctrl__enq_en ;
  logic [0:0] ctrl__enq_rdy ;
  logic [0:0] ctrl__raddr ;
  logic [0:0] ctrl__reset ;
  logic [0:0] ctrl__waddr ;
  logic [0:0] ctrl__wen ;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk ;
  CGRAData_1_1 dpath__deq_ret ;
  CGRAData_1_1 dpath__enq_msg ;
  logic [0:0] dpath__raddr ;
  logic [0:0] dpath__reset ;
  logic [0:0] dpath__waddr ;
  logic [0:0] dpath__wen ;

  NormalQueueDpathRTL__EntryType_CGRAData_1_1__num_entries_2 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component RegisterRTL Definition
// At /home/cheng/workspace/projects/cgra/vrsa/rf/RegisterRTL.py

module RegisterRTL__DataType_CGRAData_1_1__latency_1
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv__en,
  input CGRAData_1_1 recv__msg,
  output logic [0:0] recv__rdy,
  output logic [0:0] send__en,
  output CGRAData_1_1 send__msg,
  input logic [0:0] send__rdy
);
  localparam logic [31:0] latency = 32'd1;
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0] ;
  logic [1:0] queues__count [0:0] ;
  logic [0:0] queues__reset [0:0] ;
  logic [0:0] queues__deq__en [0:0] ;
  logic [0:0] queues__deq__rdy [0:0] ;
  CGRAData_1_1 queues__deq__ret [0:0] ;
  logic [0:0] queues__enq__en [0:0] ;
  CGRAData_1_1 queues__enq__msg [0:0] ;
  logic [0:0] queues__enq__rdy [0:0] ;

  NormalQueueRTL__EntryType_CGRAData_1_1__num_entries_2 queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .deq__en( queues__deq__en[0] ),
    .deq__rdy( queues__deq__rdy[0] ),
    .deq__ret( queues__deq__ret[0] ),
    .enq__en( queues__enq__en[0] ),
    .enq__msg( queues__enq__msg[0] ),
    .enq__rdy( queues__enq__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/rf/RegisterRTL.py:30
  //   @s.update
  //   def process():
  //     s.recv.rdy = s.queues[0].enq.rdy
  //     s.queues[0].enq.msg = s.recv.msg
  //     s.queues[0].enq.en  = s.recv.en and s.queues[0].enq.rdy
  //     for i in range(s.latency - 1):
  //       s.queues[i+1].enq.msg = s.queues[i].deq.ret
  //       s.queues[i+1].enq.en  = s.queues[i].deq.rdy and s.queues[i+1].enq.rdy
  //       s.queues[i].deq.en    = s.queues[i+1].enq.en
  // 
  //     s.send.msg  = s.queues[s.latency-1].deq.ret
  //     s.send.en   = s.send.rdy and s.queues[s.latency-1].deq.rdy
  //     s.queues[s.latency-1].deq.en   = s.send.en
  
  always_comb begin : process
    recv__rdy = queues__enq__rdy[0];
    queues__enq__msg[0] = recv__msg;
    queues__enq__en[0] = recv__en && queues__enq__rdy[0];
    for ( int i = 0; i < latency - 1; i += 1 ) begin
      queues__enq__msg[i + 1] = queues__deq__ret[i];
      queues__enq__en[i + 1] = queues__deq__rdy[i] && queues__enq__rdy[i + 1];
      queues__deq__en[i] = queues__enq__en[i + 1];
    end
    send__msg = queues__deq__ret[latency - 1];
    send__en = send__rdy && queues__deq__rdy[latency - 1];
    queues__deq__en[latency - 1] = send__en;
  end

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;

endmodule


// PyMTL Component TileRTL Definition
// Full name: TileRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_6_8__ctrl_mem_size_3__data_mem_size_8__num_ctrl_3__num_fu_inports_4__num_fu_outports_2__num_connect_inports_4__num_connect_outports_4__Fu_FlexibleFuRTL__FuList_[<class 'vrsa.fu.single.AdderRTL.AdderRTL'>, <class 'vrsa.fu.single.MulRTL.MulRTL'>, <class 'vrsa.fu.single.LogicRTL.LogicRTL'>, <class 'vrsa.fu.single.ShifterRTL.ShifterRTL'>, <class 'vrsa.fu.single.PhiRTL.PhiRTL'>, <class 'vrsa.fu.single.CompRTL.CompRTL'>, <class 'vrsa.fu.single.BranchRTL.BranchRTL'>, <class 'vrsa.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'vrsa.fu.single.SelRTL.SelRTL'>, <class 'vrsa.fu.vector.VectorMulComboRTL.VectorMulComboRTL'>]
// At /home/cheng/workspace/projects/cgra/vrsa/tile/TileRTL.py

module TileRTL__e04244646baa657d
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_data__en [0:3],
  input CGRAData_32_1_1 recv_data__msg [0:3],
  output logic [0:0] recv_data__rdy [0:3],
  input logic [0:0] recv_waddr__en,
  input logic [1:0] recv_waddr__msg,
  output logic [0:0] recv_waddr__rdy,
  input logic [0:0] recv_wopt__en,
  input CGRAConfig_6_4_6_8 recv_wopt__msg,
  output logic [0:0] recv_wopt__rdy,
  output logic [0:0] send_data__en [0:3],
  output CGRAData_32_1_1 send_data__msg [0:3],
  input logic [0:0] send_data__rdy [0:3],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  //-------------------------------------------------------------
  // Component channel[0:7]
  //-------------------------------------------------------------

  logic [0:0] channel__clk [0:7] ;
  logic [1:0] channel__count [0:7] ;
  logic [0:0] channel__reset [0:7] ;
  logic [0:0] channel__recv__en [0:7] ;
  CGRAData_32_1_1 channel__recv__msg [0:7] ;
  logic [0:0] channel__recv__rdy [0:7] ;
  logic [0:0] channel__send__en [0:7] ;
  CGRAData_32_1_1 channel__send__msg [0:7] ;
  logic [0:0] channel__send__rdy [0:7] ;

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__0
  (
    .clk( channel__clk[0] ),
    .count( channel__count[0] ),
    .reset( channel__reset[0] ),
    .recv__en( channel__recv__en[0] ),
    .recv__msg( channel__recv__msg[0] ),
    .recv__rdy( channel__recv__rdy[0] ),
    .send__en( channel__send__en[0] ),
    .send__msg( channel__send__msg[0] ),
    .send__rdy( channel__send__rdy[0] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__1
  (
    .clk( channel__clk[1] ),
    .count( channel__count[1] ),
    .reset( channel__reset[1] ),
    .recv__en( channel__recv__en[1] ),
    .recv__msg( channel__recv__msg[1] ),
    .recv__rdy( channel__recv__rdy[1] ),
    .send__en( channel__send__en[1] ),
    .send__msg( channel__send__msg[1] ),
    .send__rdy( channel__send__rdy[1] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__2
  (
    .clk( channel__clk[2] ),
    .count( channel__count[2] ),
    .reset( channel__reset[2] ),
    .recv__en( channel__recv__en[2] ),
    .recv__msg( channel__recv__msg[2] ),
    .recv__rdy( channel__recv__rdy[2] ),
    .send__en( channel__send__en[2] ),
    .send__msg( channel__send__msg[2] ),
    .send__rdy( channel__send__rdy[2] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__3
  (
    .clk( channel__clk[3] ),
    .count( channel__count[3] ),
    .reset( channel__reset[3] ),
    .recv__en( channel__recv__en[3] ),
    .recv__msg( channel__recv__msg[3] ),
    .recv__rdy( channel__recv__rdy[3] ),
    .send__en( channel__send__en[3] ),
    .send__msg( channel__send__msg[3] ),
    .send__rdy( channel__send__rdy[3] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__4
  (
    .clk( channel__clk[4] ),
    .count( channel__count[4] ),
    .reset( channel__reset[4] ),
    .recv__en( channel__recv__en[4] ),
    .recv__msg( channel__recv__msg[4] ),
    .recv__rdy( channel__recv__rdy[4] ),
    .send__en( channel__send__en[4] ),
    .send__msg( channel__send__msg[4] ),
    .send__rdy( channel__send__rdy[4] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__5
  (
    .clk( channel__clk[5] ),
    .count( channel__count[5] ),
    .reset( channel__reset[5] ),
    .recv__en( channel__recv__en[5] ),
    .recv__msg( channel__recv__msg[5] ),
    .recv__rdy( channel__recv__rdy[5] ),
    .send__en( channel__send__en[5] ),
    .send__msg( channel__send__msg[5] ),
    .send__rdy( channel__send__rdy[5] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__6
  (
    .clk( channel__clk[6] ),
    .count( channel__count[6] ),
    .reset( channel__reset[6] ),
    .recv__en( channel__recv__en[6] ),
    .recv__msg( channel__recv__msg[6] ),
    .recv__rdy( channel__recv__rdy[6] ),
    .send__en( channel__send__en[6] ),
    .send__msg( channel__send__msg[6] ),
    .send__rdy( channel__send__rdy[6] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__7
  (
    .clk( channel__clk[7] ),
    .count( channel__count[7] ),
    .reset( channel__reset[7] ),
    .recv__en( channel__recv__en[7] ),
    .recv__msg( channel__recv__msg[7] ),
    .recv__rdy( channel__recv__rdy[7] ),
    .send__en( channel__send__en[7] ),
    .send__msg( channel__send__msg[7] ),
    .send__rdy( channel__send__rdy[7] )
  );

  //-------------------------------------------------------------
  // End of component channel[0:7]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component crossbar
  //-------------------------------------------------------------

  logic [0:0] crossbar__clk ;
  logic [0:0] crossbar__reset ;
  logic [0:0] crossbar__recv_data__en [0:5] ;
  CGRAData_32_1_1 crossbar__recv_data__msg [0:5] ;
  logic [0:0] crossbar__recv_data__rdy [0:5] ;
  logic [0:0] crossbar__recv_opt__en ;
  CGRAConfig_6_4_6_8 crossbar__recv_opt__msg ;
  logic [0:0] crossbar__recv_opt__rdy ;
  logic [0:0] crossbar__send_data__en [0:7] ;
  CGRAData_32_1_1 crossbar__send_data__msg [0:7] ;
  logic [0:0] crossbar__send_data__rdy [0:7] ;
  logic [0:0] crossbar__send_predicate__en ;
  CGRAData_1_1 crossbar__send_predicate__msg ;
  logic [0:0] crossbar__send_predicate__rdy ;

  CrossbarRTL__20918f721d5f331c crossbar
  (
    .clk( crossbar__clk ),
    .reset( crossbar__reset ),
    .recv_data__en( crossbar__recv_data__en ),
    .recv_data__msg( crossbar__recv_data__msg ),
    .recv_data__rdy( crossbar__recv_data__rdy ),
    .recv_opt__en( crossbar__recv_opt__en ),
    .recv_opt__msg( crossbar__recv_opt__msg ),
    .recv_opt__rdy( crossbar__recv_opt__rdy ),
    .send_data__en( crossbar__send_data__en ),
    .send_data__msg( crossbar__send_data__msg ),
    .send_data__rdy( crossbar__send_data__rdy ),
    .send_predicate__en( crossbar__send_predicate__en ),
    .send_predicate__msg( crossbar__send_predicate__msg ),
    .send_predicate__rdy( crossbar__send_predicate__rdy )
  );

  //-------------------------------------------------------------
  // End of component crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_mem
  //-------------------------------------------------------------

  logic [0:0] ctrl_mem__clk ;
  logic [0:0] ctrl_mem__reset ;
  logic [0:0] ctrl_mem__recv_ctrl__en ;
  CGRAConfig_6_4_6_8 ctrl_mem__recv_ctrl__msg ;
  logic [0:0] ctrl_mem__recv_ctrl__rdy ;
  logic [0:0] ctrl_mem__recv_waddr__en ;
  logic [1:0] ctrl_mem__recv_waddr__msg ;
  logic [0:0] ctrl_mem__recv_waddr__rdy ;
  logic [0:0] ctrl_mem__send_ctrl__en ;
  CGRAConfig_6_4_6_8 ctrl_mem__send_ctrl__msg ;
  logic [0:0] ctrl_mem__send_ctrl__rdy ;

  CtrlMemRTL__8f238acfb01302b1 ctrl_mem
  (
    .clk( ctrl_mem__clk ),
    .reset( ctrl_mem__reset ),
    .recv_ctrl__en( ctrl_mem__recv_ctrl__en ),
    .recv_ctrl__msg( ctrl_mem__recv_ctrl__msg ),
    .recv_ctrl__rdy( ctrl_mem__recv_ctrl__rdy ),
    .recv_waddr__en( ctrl_mem__recv_waddr__en ),
    .recv_waddr__msg( ctrl_mem__recv_waddr__msg ),
    .recv_waddr__rdy( ctrl_mem__recv_waddr__rdy ),
    .send_ctrl__en( ctrl_mem__send_ctrl__en ),
    .send_ctrl__msg( ctrl_mem__send_ctrl__msg ),
    .send_ctrl__rdy( ctrl_mem__send_ctrl__rdy )
  );

  //-------------------------------------------------------------
  // End of component ctrl_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component element
  //-------------------------------------------------------------

  logic [0:0] element__clk ;
  logic [1:0] element__recv_in_count [0:3] ;
  logic [0:0] element__reset ;
  logic [0:0] element__from_mem_rdata__en [0:9] ;
  CGRAData_32_1_1 element__from_mem_rdata__msg [0:9] ;
  logic [0:0] element__from_mem_rdata__rdy [0:9] ;
  logic [0:0] element__recv_const__en ;
  CGRAData_32_1_1 element__recv_const__msg ;
  logic [0:0] element__recv_const__rdy ;
  logic [0:0] element__recv_in__en [0:3] ;
  CGRAData_32_1_1 element__recv_in__msg [0:3] ;
  logic [0:0] element__recv_in__rdy [0:3] ;
  logic [0:0] element__recv_opt__en ;
  CGRAConfig_6_4_6_8 element__recv_opt__msg ;
  logic [0:0] element__recv_opt__rdy ;
  logic [0:0] element__recv_predicate__en ;
  CGRAData_1_1 element__recv_predicate__msg ;
  logic [0:0] element__recv_predicate__rdy ;
  logic [0:0] element__send_out__en [0:1] ;
  CGRAData_32_1_1 element__send_out__msg [0:1] ;
  logic [0:0] element__send_out__rdy [0:1] ;
  logic [0:0] element__to_mem_raddr__en [0:9] ;
  logic [2:0] element__to_mem_raddr__msg [0:9] ;
  logic [0:0] element__to_mem_raddr__rdy [0:9] ;
  logic [0:0] element__to_mem_waddr__en [0:9] ;
  logic [2:0] element__to_mem_waddr__msg [0:9] ;
  logic [0:0] element__to_mem_waddr__rdy [0:9] ;
  logic [0:0] element__to_mem_wdata__en [0:9] ;
  CGRAData_32_1_1 element__to_mem_wdata__msg [0:9] ;
  logic [0:0] element__to_mem_wdata__rdy [0:9] ;

  FlexibleFuRTL__af19c74e4933e98f element
  (
    .clk( element__clk ),
    .recv_in_count( element__recv_in_count ),
    .reset( element__reset ),
    .from_mem_rdata__en( element__from_mem_rdata__en ),
    .from_mem_rdata__msg( element__from_mem_rdata__msg ),
    .from_mem_rdata__rdy( element__from_mem_rdata__rdy ),
    .recv_const__en( element__recv_const__en ),
    .recv_const__msg( element__recv_const__msg ),
    .recv_const__rdy( element__recv_const__rdy ),
    .recv_in__en( element__recv_in__en ),
    .recv_in__msg( element__recv_in__msg ),
    .recv_in__rdy( element__recv_in__rdy ),
    .recv_opt__en( element__recv_opt__en ),
    .recv_opt__msg( element__recv_opt__msg ),
    .recv_opt__rdy( element__recv_opt__rdy ),
    .recv_predicate__en( element__recv_predicate__en ),
    .recv_predicate__msg( element__recv_predicate__msg ),
    .recv_predicate__rdy( element__recv_predicate__rdy ),
    .send_out__en( element__send_out__en ),
    .send_out__msg( element__send_out__msg ),
    .send_out__rdy( element__send_out__rdy ),
    .to_mem_raddr__en( element__to_mem_raddr__en ),
    .to_mem_raddr__msg( element__to_mem_raddr__msg ),
    .to_mem_raddr__rdy( element__to_mem_raddr__rdy ),
    .to_mem_waddr__en( element__to_mem_waddr__en ),
    .to_mem_waddr__msg( element__to_mem_waddr__msg ),
    .to_mem_waddr__rdy( element__to_mem_waddr__rdy ),
    .to_mem_wdata__en( element__to_mem_wdata__en ),
    .to_mem_wdata__msg( element__to_mem_wdata__msg ),
    .to_mem_wdata__rdy( element__to_mem_wdata__rdy )
  );

  //-------------------------------------------------------------
  // End of component element
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reg_predicate
  //-------------------------------------------------------------

  logic [0:0] reg_predicate__clk ;
  logic [0:0] reg_predicate__reset ;
  logic [0:0] reg_predicate__recv__en ;
  CGRAData_1_1 reg_predicate__recv__msg ;
  logic [0:0] reg_predicate__recv__rdy ;
  logic [0:0] reg_predicate__send__en ;
  CGRAData_1_1 reg_predicate__send__msg ;
  logic [0:0] reg_predicate__send__rdy ;

  RegisterRTL__DataType_CGRAData_1_1__latency_1 reg_predicate
  (
    .clk( reg_predicate__clk ),
    .reset( reg_predicate__reset ),
    .recv__en( reg_predicate__recv__en ),
    .recv__msg( reg_predicate__recv__msg ),
    .recv__rdy( reg_predicate__recv__rdy ),
    .send__en( reg_predicate__send__en ),
    .send__msg( reg_predicate__send__msg ),
    .send__rdy( reg_predicate__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component reg_predicate
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/cheng/workspace/projects/cgra/vrsa/tile/TileRTL.py:101
  // @s.update
  // def update_opt():
  //   s.element.recv_opt.msg  = s.ctrl_mem.send_ctrl.msg
  //   s.crossbar.recv_opt.msg = s.ctrl_mem.send_ctrl.msg
  //   s.element.recv_opt.en  = s.ctrl_mem.send_ctrl.en
  //   s.crossbar.recv_opt.en = s.ctrl_mem.send_ctrl.en
  //   s.ctrl_mem.send_ctrl.rdy = s.element.recv_opt.rdy and s.crossbar.recv_opt.rdy
  
  always_comb begin : update_opt
    element__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    crossbar__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    element__recv_opt__en = ctrl_mem__send_ctrl__en;
    crossbar__recv_opt__en = ctrl_mem__send_ctrl__en;
    ctrl_mem__send_ctrl__rdy = element__recv_opt__rdy && crossbar__recv_opt__rdy;
  end

  assign element__clk = clk;
  assign element__reset = reset;
  assign crossbar__clk = clk;
  assign crossbar__reset = reset;
  assign ctrl_mem__clk = clk;
  assign ctrl_mem__reset = reset;
  assign channel__clk[0] = clk;
  assign channel__reset[0] = reset;
  assign channel__clk[1] = clk;
  assign channel__reset[1] = reset;
  assign channel__clk[2] = clk;
  assign channel__reset[2] = reset;
  assign channel__clk[3] = clk;
  assign channel__reset[3] = reset;
  assign channel__clk[4] = clk;
  assign channel__reset[4] = reset;
  assign channel__clk[5] = clk;
  assign channel__reset[5] = reset;
  assign channel__clk[6] = clk;
  assign channel__reset[6] = reset;
  assign channel__clk[7] = clk;
  assign channel__reset[7] = reset;
  assign reg_predicate__clk = clk;
  assign reg_predicate__reset = reset;
  assign ctrl_mem__recv_waddr__en = recv_waddr__en;
  assign ctrl_mem__recv_waddr__msg = recv_waddr__msg;
  assign recv_waddr__rdy = ctrl_mem__recv_waddr__rdy;
  assign ctrl_mem__recv_ctrl__en = recv_wopt__en;
  assign ctrl_mem__recv_ctrl__msg = recv_wopt__msg;
  assign recv_wopt__rdy = ctrl_mem__recv_ctrl__rdy;
  assign element__to_mem_raddr__rdy[0] = 1'd0;
  assign element__from_mem_rdata__en[0] = 1'd0;
  assign element__from_mem_rdata__msg[0] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[0] = 1'd0;
  assign element__to_mem_wdata__rdy[0] = 1'd0;
  assign element__to_mem_raddr__rdy[1] = 1'd0;
  assign element__from_mem_rdata__en[1] = 1'd0;
  assign element__from_mem_rdata__msg[1] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[1] = 1'd0;
  assign element__to_mem_wdata__rdy[1] = 1'd0;
  assign element__to_mem_raddr__rdy[2] = 1'd0;
  assign element__from_mem_rdata__en[2] = 1'd0;
  assign element__from_mem_rdata__msg[2] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[2] = 1'd0;
  assign element__to_mem_wdata__rdy[2] = 1'd0;
  assign element__to_mem_raddr__rdy[3] = 1'd0;
  assign element__from_mem_rdata__en[3] = 1'd0;
  assign element__from_mem_rdata__msg[3] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[3] = 1'd0;
  assign element__to_mem_wdata__rdy[3] = 1'd0;
  assign element__to_mem_raddr__rdy[4] = 1'd0;
  assign element__from_mem_rdata__en[4] = 1'd0;
  assign element__from_mem_rdata__msg[4] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[4] = 1'd0;
  assign element__to_mem_wdata__rdy[4] = 1'd0;
  assign element__to_mem_raddr__rdy[5] = 1'd0;
  assign element__from_mem_rdata__en[5] = 1'd0;
  assign element__from_mem_rdata__msg[5] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[5] = 1'd0;
  assign element__to_mem_wdata__rdy[5] = 1'd0;
  assign element__to_mem_raddr__rdy[6] = 1'd0;
  assign element__from_mem_rdata__en[6] = 1'd0;
  assign element__from_mem_rdata__msg[6] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[6] = 1'd0;
  assign element__to_mem_wdata__rdy[6] = 1'd0;
  assign to_mem_raddr__en = element__to_mem_raddr__en[7];
  assign to_mem_raddr__msg = element__to_mem_raddr__msg[7];
  assign element__to_mem_raddr__rdy[7] = to_mem_raddr__rdy;
  assign element__from_mem_rdata__en[7] = from_mem_rdata__en;
  assign element__from_mem_rdata__msg[7] = from_mem_rdata__msg;
  assign from_mem_rdata__rdy = element__from_mem_rdata__rdy[7];
  assign to_mem_waddr__en = element__to_mem_waddr__en[7];
  assign to_mem_waddr__msg = element__to_mem_waddr__msg[7];
  assign element__to_mem_waddr__rdy[7] = to_mem_waddr__rdy;
  assign to_mem_wdata__en = element__to_mem_wdata__en[7];
  assign to_mem_wdata__msg = element__to_mem_wdata__msg[7];
  assign element__to_mem_wdata__rdy[7] = to_mem_wdata__rdy;
  assign element__to_mem_raddr__rdy[8] = 1'd0;
  assign element__from_mem_rdata__en[8] = 1'd0;
  assign element__from_mem_rdata__msg[8] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[8] = 1'd0;
  assign element__to_mem_wdata__rdy[8] = 1'd0;
  assign element__to_mem_raddr__rdy[9] = 1'd0;
  assign element__from_mem_rdata__en[9] = 1'd0;
  assign element__from_mem_rdata__msg[9] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[9] = 1'd0;
  assign element__to_mem_wdata__rdy[9] = 1'd0;
  assign crossbar__recv_data__en[0] = recv_data__en[0];
  assign crossbar__recv_data__msg[0] = recv_data__msg[0];
  assign recv_data__rdy[0] = crossbar__recv_data__rdy[0];
  assign crossbar__recv_data__en[1] = recv_data__en[1];
  assign crossbar__recv_data__msg[1] = recv_data__msg[1];
  assign recv_data__rdy[1] = crossbar__recv_data__rdy[1];
  assign crossbar__recv_data__en[2] = recv_data__en[2];
  assign crossbar__recv_data__msg[2] = recv_data__msg[2];
  assign recv_data__rdy[2] = crossbar__recv_data__rdy[2];
  assign crossbar__recv_data__en[3] = recv_data__en[3];
  assign crossbar__recv_data__msg[3] = recv_data__msg[3];
  assign recv_data__rdy[3] = crossbar__recv_data__rdy[3];
  assign channel__recv__en[0] = crossbar__send_data__en[0];
  assign channel__recv__msg[0] = crossbar__send_data__msg[0];
  assign crossbar__send_data__rdy[0] = channel__recv__rdy[0];
  assign channel__recv__en[1] = crossbar__send_data__en[1];
  assign channel__recv__msg[1] = crossbar__send_data__msg[1];
  assign crossbar__send_data__rdy[1] = channel__recv__rdy[1];
  assign channel__recv__en[2] = crossbar__send_data__en[2];
  assign channel__recv__msg[2] = crossbar__send_data__msg[2];
  assign crossbar__send_data__rdy[2] = channel__recv__rdy[2];
  assign channel__recv__en[3] = crossbar__send_data__en[3];
  assign channel__recv__msg[3] = crossbar__send_data__msg[3];
  assign crossbar__send_data__rdy[3] = channel__recv__rdy[3];
  assign channel__recv__en[4] = crossbar__send_data__en[4];
  assign channel__recv__msg[4] = crossbar__send_data__msg[4];
  assign crossbar__send_data__rdy[4] = channel__recv__rdy[4];
  assign channel__recv__en[5] = crossbar__send_data__en[5];
  assign channel__recv__msg[5] = crossbar__send_data__msg[5];
  assign crossbar__send_data__rdy[5] = channel__recv__rdy[5];
  assign channel__recv__en[6] = crossbar__send_data__en[6];
  assign channel__recv__msg[6] = crossbar__send_data__msg[6];
  assign crossbar__send_data__rdy[6] = channel__recv__rdy[6];
  assign channel__recv__en[7] = crossbar__send_data__en[7];
  assign channel__recv__msg[7] = crossbar__send_data__msg[7];
  assign crossbar__send_data__rdy[7] = channel__recv__rdy[7];
  assign reg_predicate__recv__en = crossbar__send_predicate__en;
  assign reg_predicate__recv__msg = crossbar__send_predicate__msg;
  assign crossbar__send_predicate__rdy = reg_predicate__recv__rdy;
  assign element__recv_predicate__en = reg_predicate__send__en;
  assign element__recv_predicate__msg = reg_predicate__send__msg;
  assign reg_predicate__send__rdy = element__recv_predicate__rdy;
  assign send_data__en[0] = channel__send__en[0];
  assign send_data__msg[0] = channel__send__msg[0];
  assign channel__send__rdy[0] = send_data__rdy[0];
  assign send_data__en[1] = channel__send__en[1];
  assign send_data__msg[1] = channel__send__msg[1];
  assign channel__send__rdy[1] = send_data__rdy[1];
  assign send_data__en[2] = channel__send__en[2];
  assign send_data__msg[2] = channel__send__msg[2];
  assign channel__send__rdy[2] = send_data__rdy[2];
  assign send_data__en[3] = channel__send__en[3];
  assign send_data__msg[3] = channel__send__msg[3];
  assign channel__send__rdy[3] = send_data__rdy[3];
  assign element__recv_in__en[0] = channel__send__en[4];
  assign element__recv_in__msg[0] = channel__send__msg[4];
  assign channel__send__rdy[4] = element__recv_in__rdy[0];
  assign element__recv_in_count[0] = channel__count[4];
  assign element__recv_in__en[1] = channel__send__en[5];
  assign element__recv_in__msg[1] = channel__send__msg[5];
  assign channel__send__rdy[5] = element__recv_in__rdy[1];
  assign element__recv_in_count[1] = channel__count[5];
  assign element__recv_in__en[2] = channel__send__en[6];
  assign element__recv_in__msg[2] = channel__send__msg[6];
  assign channel__send__rdy[6] = element__recv_in__rdy[2];
  assign element__recv_in_count[2] = channel__count[6];
  assign element__recv_in__en[3] = channel__send__en[7];
  assign element__recv_in__msg[3] = channel__send__msg[7];
  assign channel__send__rdy[7] = element__recv_in__rdy[3];
  assign element__recv_in_count[3] = channel__count[7];
  assign crossbar__recv_data__en[4] = element__send_out__en[0];
  assign crossbar__recv_data__msg[4] = element__send_out__msg[0];
  assign element__send_out__rdy[0] = crossbar__recv_data__rdy[4];
  assign crossbar__recv_data__en[5] = element__send_out__en[1];
  assign crossbar__recv_data__msg[5] = element__send_out__msg[1];
  assign element__send_out__rdy[1] = crossbar__recv_data__rdy[5];

endmodule
