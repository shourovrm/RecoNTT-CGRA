//-------------------------------------------------------------------------
// Tile__f271b52ddf290f3e.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct CGRAData_32_1 Definition
// At BitStruct CGRAData_32_1
typedef struct packed {
  logic [31:0] payload ;
  logic [0:0] predicate ;
} CGRAData_32_1;

// PyMTL BitStruct CGRAConfig_5_6_8 Definition
// At BitStruct CGRAConfig_5_6_8
typedef struct packed {
  logic [4:0] ctrl ;
  logic [7:0][2:0] outport ;
} CGRAConfig_5_6_8;

// PyMTL Component NormalQueueCtrlRTL Definition
// At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] deq_en,
  output logic [0:0] deq_rdy,
  input logic [0:0] enq_en,
  output logic [0:0] enq_rdy,
  output logic [0:0] raddr,
  input logic [0:0] reset,
  output logic [0:0] waddr,
  output logic [0:0] wen
);
  localparam logic [0:0] last_idx = 1'd1;
  localparam logic [1:0] num_entries = 2'd2;
  logic [0:0] deq_xfer ;
  logic [0:0] enq_xfer ;
  logic [0:0] head ;
  logic [0:0] tail ;

  // PyMTL Lambda Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py:86
  // s.deq_rdy //= lambda: ~s.reset & ( s.count > CountType(0) )
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_deq_rdy
    deq_rdy = ( ~reset ) & ( count > 2'd0 );
  end

  // PyMTL Lambda Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py:89
  // s.deq_xfer //= lambda: s.deq_en & s.deq_rdy
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_deq_xfer
    deq_xfer = deq_en & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py:85
  // s.enq_rdy //= lambda: ~s.reset & ( s.count < s.num_entries )
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_enq_rdy
    enq_rdy = ( ~reset ) & ( count < num_entries );
  end

  // PyMTL Lambda Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py:88
  // s.enq_xfer //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_dut_channel_0__queues_0__ctrl_enq_xfer
    enq_xfer = enq_en & enq_rdy;
  end

  // PyMTL Update Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py:91
  // @s.update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= PtrType(0)
  //     s.tail  <<= PtrType(0)
  //     s.count <<= CountType(0)
  // 
  //   else:
  //     if s.deq_xfer:
  //       s.head <<= s.head + PtrType(1) if s.head < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer:
  //       s.tail <<= s.tail + PtrType(1) if s.tail < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer & ~s.deq_xfer:
  //       s.count <<= s.count + CountType(1)
  //     if ~s.enq_xfer & s.deq_xfer:
  //       s.count <<= s.count - CountType(1)
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( deq_xfer ) begin
        head <= ( head < last_idx ) ? head + 1'd1 : 1'd0;
      end
      if ( enq_xfer ) begin
        tail <= ( tail < last_idx ) ? tail + 1'd1 : 1'd0;
      end
      if ( enq_xfer & ( ~deq_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~enq_xfer ) & deq_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = enq_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAData_32_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__5e83938a33bc07e5
(
  input logic [0:0] clk,
  input logic [0:0] raddr [0:0],
  output CGRAData_32_1 rdata [0:0],
  input logic [0:0] reset,
  input logic [0:0] waddr [0:0],
  input CGRAData_32_1 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAData_32_1 regs [0:1] ;

  // PyMTL Update Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py

module NormalQueueDpathRTL__EntryType_CGRAData_32_1__num_entries_2
(
  input logic [0:0] clk,
  output CGRAData_32_1 deq_ret,
  input CGRAData_32_1 enq_msg,
  input logic [0:0] raddr,
  input logic [0:0] reset,
  input logic [0:0] waddr,
  input logic [0:0] wen
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk ;
  logic [0:0] queue__raddr [0:0] ;
  CGRAData_32_1 queue__rdata [0:0] ;
  logic [0:0] queue__reset ;
  logic [0:0] queue__waddr [0:0] ;
  CGRAData_32_1 queue__wdata [0:0] ;
  logic [0:0] queue__wen [0:0] ;

  RegisterFile__5e83938a33bc07e5 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/queues.py

module NormalQueueRTL__EntryType_CGRAData_32_1__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] reset,
  input logic [0:0] deq__en,
  output logic [0:0] deq__rdy,
  output CGRAData_32_1 deq__ret,
  input logic [0:0] enq__en,
  input CGRAData_32_1 enq__msg,
  output logic [0:0] enq__rdy
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk ;
  logic [1:0] ctrl__count ;
  logic [0:0] ctrl__deq_en ;
  logic [0:0] ctrl__deq_rdy ;
  logic [0:0] ctrl__enq_en ;
  logic [0:0] ctrl__enq_rdy ;
  logic [0:0] ctrl__raddr ;
  logic [0:0] ctrl__reset ;
  logic [0:0] ctrl__waddr ;
  logic [0:0] ctrl__wen ;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk ;
  CGRAData_32_1 dpath__deq_ret ;
  CGRAData_32_1 dpath__enq_msg ;
  logic [0:0] dpath__raddr ;
  logic [0:0] dpath__reset ;
  logic [0:0] dpath__waddr ;
  logic [0:0] dpath__wen ;

  NormalQueueDpathRTL__EntryType_CGRAData_32_1__num_entries_2 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component Channel Definition
// At /home/ct535/project/PyCGRA/noc/Channel.py

module Channel__DataType_CGRAData_32_1__latency_1
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv__en,
  input CGRAData_32_1 recv__msg,
  output logic [0:0] recv__rdy,
  output logic [0:0] send__en,
  output CGRAData_32_1 send__msg,
  input logic [0:0] send__rdy
);
  localparam logic [31:0] latency = 32'd1;
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0] ;
  logic [1:0] queues__count [0:0] ;
  logic [0:0] queues__reset [0:0] ;
  logic [0:0] queues__deq__en [0:0] ;
  logic [0:0] queues__deq__rdy [0:0] ;
  CGRAData_32_1 queues__deq__ret [0:0] ;
  logic [0:0] queues__enq__en [0:0] ;
  CGRAData_32_1 queues__enq__msg [0:0] ;
  logic [0:0] queues__enq__rdy [0:0] ;

  NormalQueueRTL__EntryType_CGRAData_32_1__num_entries_2 queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .deq__en( queues__deq__en[0] ),
    .deq__rdy( queues__deq__rdy[0] ),
    .deq__ret( queues__deq__ret[0] ),
    .enq__en( queues__enq__en[0] ),
    .enq__msg( queues__enq__msg[0] ),
    .enq__rdy( queues__enq__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/noc/Channel.py:36
  // @s.update
  // def process():
  //   s.queues[0].enq.msg = s.recv.msg
  //   s.queues[0].enq.en  = s.recv.en and s.queues[0].enq.rdy
  //   for i in range(s.latency - 1):
  //     s.queues[i+1].enq.msg = s.queues[i].deq.ret
  //     s.queues[i+1].enq.en  = s.queues[i].deq.rdy and s.queues[i+1].enq.rdy
  //     s.queues[i].deq.en    = s.queues[i+1].enq.en
  // 
  //   s.send.msg  = s.queues[s.latency-1].deq.ret
  //   s.send.en   = s.send.rdy and s.queues[s.latency-1].deq.rdy
  //   s.queues[s.latency-1].deq.en   = s.send.en
  
  always_comb begin : process
    queues__enq__msg[0] = recv__msg;
    queues__enq__en[0] = recv__en && queues__enq__rdy[0];
    for ( int i = 0; i < latency - 1; i += 1 ) begin
      queues__enq__msg[i + 1] = queues__deq__ret[i];
      queues__enq__en[i + 1] = queues__deq__rdy[i] && queues__enq__rdy[i + 1];
      queues__deq__en[i] = queues__enq__en[i + 1];
    end
    send__msg = queues__deq__ret[latency - 1];
    send__en = send__rdy && queues__deq__rdy[latency - 1];
    queues__deq__en[latency - 1] = send__en;
  end

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign recv__rdy = queues__enq__rdy[0];

endmodule


// PyMTL Component Crossbar Definition
// Full name: Crossbar__DataType_CGRAData_32_1__CtrlType_CGRAConfig_5_6_8__num_inports_6__num_outports_8
// At /home/ct535/project/PyCGRA/noc/Crossbar.py

module Crossbar__9de0b627a60fd452
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_data__en [0:5],
  input CGRAData_32_1 recv_data__msg [0:5],
  output logic [0:0] recv_data__rdy [0:5],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_5_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  output logic [0:0] send_data__en [0:7],
  output CGRAData_32_1 send_data__msg [0:7],
  input logic [0:0] send_data__rdy [0:7]
);
  localparam logic [4:0] __const__OPT_START = 5'd0;
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd8;
  logic [0:0] __tmpvar__update_signal_out_rdy ;
  logic [2:0] __tmpvar__update_signal_in_dir ;

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/noc/Crossbar.py:32
  // @s.update
  // def update_signal():
  //   out_rdy = b1( 0 )
  //   if s.recv_opt.msg.ctrl != OPT_START:
  //     for i in range( num_outports ):
  //       in_dir  = s.recv_opt.msg.outport[i]
  //       out_rdy = out_rdy | s.send_data[i].rdy
  //       if in_dir > OutType( 0 ):
  //         in_dir = in_dir - OutType( 1 )
  //         s.recv_data[in_dir].rdy = s.send_data[i].rdy
  //         s.send_data[i].en       = s.recv_data[in_dir].en
  //         s.send_data[i].msg      = s.recv_data[in_dir].msg
  //   else:
  //     for i in range( num_outports ):
  //       s.send_data[i].en = b1( 0 )
  //   s.recv_opt.rdy = out_rdy
  
  always_comb begin : update_signal
    __tmpvar__update_signal_out_rdy = 1'd0;
    if ( recv_opt__msg.ctrl != __const__OPT_START ) begin
      for ( int i = 0; i < __const__num_outports_at_update_signal; i += 1 ) begin
        __tmpvar__update_signal_in_dir = recv_opt__msg.outport[i];
        __tmpvar__update_signal_out_rdy = __tmpvar__update_signal_out_rdy | send_data__rdy[i];
        if ( __tmpvar__update_signal_in_dir > 3'd0 ) begin
          __tmpvar__update_signal_in_dir = __tmpvar__update_signal_in_dir - 3'd1;
          recv_data__rdy[__tmpvar__update_signal_in_dir] = send_data__rdy[i];
          send_data__en[i] = recv_data__en[__tmpvar__update_signal_in_dir];
          send_data__msg[i] = recv_data__msg[__tmpvar__update_signal_in_dir];
        end
      end
    end
    else
      for ( int i = 0; i < __const__num_outports_at_update_signal; i += 1 )
        send_data__en[i] = 1'd0;
    recv_opt__rdy = __tmpvar__update_signal_out_rdy;
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAConfig_5_6_8__nregs_3__rd_ports_1__wr_ports_1__const_zero_False
// At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__d0a98e0d377198ba
(
  input logic [0:0] clk,
  input logic [1:0] raddr [0:0],
  output CGRAConfig_5_6_8 rdata [0:0],
  input logic [0:0] reset,
  input logic [1:0] waddr [0:0],
  input CGRAConfig_5_6_8 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAConfig_5_6_8 regs [0:2] ;

  // PyMTL Update Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/ct535/project/venv_latest_pymtl3/src/pymtl3/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component CtrlMem Definition
// At /home/ct535/project/PyCGRA/mem/ctrl/CtrlMem.py

module CtrlMem__CtrlType_CGRAConfig_5_6_8__ctrl_mem_size_3__num_ctrl_3
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_ctrl__en,
  input CGRAConfig_5_6_8 recv_ctrl__msg,
  output logic [0:0] recv_ctrl__rdy,
  input logic [0:0] recv_waddr__en,
  input logic [1:0] recv_waddr__msg,
  output logic [0:0] recv_waddr__rdy,
  output logic [0:0] send_ctrl__en,
  output CGRAConfig_5_6_8 send_ctrl__msg,
  input logic [0:0] send_ctrl__rdy
);
  localparam logic [31:0] __const__num_ctrl_at_update_signal = 32'd3;
  localparam logic [4:0] __const__OPT_START = 5'd0;
  localparam logic [31:0] __const__num_ctrl_at_update_raddr = 32'd3;
  localparam logic [1:0] __const__last_item_at_update_raddr = 2'd2;
  logic [1:0] times ;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk ;
  logic [1:0] reg_file__raddr [0:0] ;
  CGRAConfig_5_6_8 reg_file__rdata [0:0] ;
  logic [0:0] reg_file__reset ;
  logic [1:0] reg_file__waddr [0:0] ;
  CGRAConfig_5_6_8 reg_file__wdata [0:0] ;
  logic [0:0] reg_file__wen [0:0] ;

  RegisterFile__d0a98e0d377198ba reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/mem/ctrl/CtrlMem.py:45
  // @s.update
  // def update_signal():
  //   if s.times == TimeType( num_ctrl ) or s.reg_file.rdata[0].ctrl == OPT_START:
  //     s.send_ctrl.en = b1( 0 )
  //   else:
  //     s.send_ctrl.en  = s.send_ctrl.rdy # s.recv_raddr[i].rdy
  //   s.recv_waddr.rdy = b1( 1 )
  //   s.recv_ctrl.rdy = b1( 1 )
  
  always_comb begin : update_signal
    if ( ( times == 2'd3 ) || ( reg_file__rdata[0].ctrl == __const__OPT_START ) ) begin
      send_ctrl__en = 1'd0;
    end
    else
      send_ctrl__en = send_ctrl__rdy;
    recv_waddr__rdy = 1'd1;
    recv_ctrl__rdy = 1'd1;
  end

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/mem/ctrl/CtrlMem.py:54
  // @s.update_ff
  // def update_raddr():
  //   if s.reg_file.rdata[0].ctrl != OPT_START:
  //     if s.times < TimeType( num_ctrl ):
  //       s.times <<= s.times + TimeType( 1 )
  //     if s.reg_file.raddr[0] < last_item:
  //       s.reg_file.raddr[0] <<= s.reg_file.raddr[0] + AddrType( 1 )
  //     else:
  //       s.reg_file.raddr[0] <<= AddrType( 0 )
  
  always_ff @(posedge clk) begin : update_raddr
    if ( reg_file__rdata[0].ctrl != __const__OPT_START ) begin
      if ( times < 2'd3 ) begin
        times <= times + 2'd1;
      end
      if ( reg_file__raddr[0] < __const__last_item_at_update_raddr ) begin
        reg_file__raddr[0] <= reg_file__raddr[0] + 2'd1;
      end
      else
        reg_file__raddr[0] <= 2'd0;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;
  assign send_ctrl__msg = reg_file__rdata[0];
  assign reg_file__waddr[0] = recv_waddr__msg;
  assign reg_file__wdata[0] = recv_ctrl__msg;
  assign reg_file__wen[0] = recv_waddr__en;

endmodule


// PyMTL Component Alu Definition
// Full name: Alu__DataType_CGRAData_32_1__ConfigType_CGRAConfig_5_6_8__num_inports_4__num_outports_2__data_mem_size_8
// At /home/ct535/project/PyCGRA/fu/single/Alu.py

module Alu__69fcd339a65ec916
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_5_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1 const_one = { 32'd1, 1'd1 };
  localparam CGRAData_32_1 const_zero = { 32'd0, 1'd0 };
  localparam logic [31:0] __const__num_inports_at_update_signal = 32'd4;
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [4:0] __const__OPT_ADD = 5'd2;
  localparam logic [4:0] __const__OPT_ADD_CONST = 5'd25;
  localparam logic [4:0] __const__OPT_INC = 5'd3;
  localparam logic [4:0] __const__OPT_SUB = 5'd4;

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/fu/single/Alu.py:27
  // @s.update
  // def comb_logic():
  //   s.send_out[0].msg.predicate = s.recv_in[0].msg.predicate and\
  //                                 s.recv_in[1].msg.predicate
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en# and s.send_out[j].rdy and s.recv_in[0].en and s.recv_in[1].en
  //   if s.recv_opt.msg.ctrl == OPT_ADD:
  //     s.send_out[0].msg.payload = s.recv_in[0].msg.payload + s.recv_in[1].msg.payload
  //   elif s.recv_opt.msg.ctrl == OPT_ADD_CONST:
  //     s.send_out[0].msg.payload = s.recv_in[0].msg.payload + s.recv_const.msg.payload
  //   elif s.recv_opt.msg.ctrl == OPT_INC:
  //     s.send_out[0].msg.payload = s.recv_in[0].msg.payload + s.const_one.payload
  //   elif s.recv_opt.msg.ctrl == OPT_SUB:
  //     s.send_out[0].msg.payload = s.recv_in[0].msg.payload - s.recv_in[1].msg.payload
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  
  always_comb begin : comb_logic
    send_out__msg[0].predicate = recv_in__msg[0].predicate && recv_in__msg[1].predicate;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_ADD ) begin
      send_out__msg[0].payload = recv_in__msg[0].payload + recv_in__msg[1].payload;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_ADD_CONST ) begin
      send_out__msg[0].payload = recv_in__msg[0].payload + recv_const__msg.payload;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_INC ) begin
      send_out__msg[0].payload = recv_in__msg[0].payload + const_one.payload;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_SUB ) begin
      send_out__msg[0].payload = recv_in__msg[0].payload - recv_in__msg[1].payload;
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/fu/basic/Fu.py:46
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/fu/basic/Fu.py:36
  // @s.update
  // def update_signal():
  //   for i in range( num_inports ):
  //     for j in range( num_outports ):
  //       s.recv_in[i].rdy = s.send_out[j].rdy or s.recv_in[i].rdy
  // 
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int i = 0; i < __const__num_inports_at_update_signal; i += 1 )
      for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 )
        recv_in__rdy[i] = send_out__rdy[j] || recv_in__rdy[i];
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component FlexibleFu Definition
// Full name: FlexibleFu__DataType_CGRAData_32_1__CtrlType_CGRAConfig_5_6_8__num_inports_4__num_outports_2__data_mem_size_8__FuList_[<class 'PyCGRA.fu.single.Alu.Alu'>]
// At /home/ct535/project/PyCGRA/fu/flexible/FlexibleFu.py

module FlexibleFu__4cb8ece074a97746
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en [0:0],
  input CGRAData_32_1 from_mem_rdata__msg [0:0],
  output logic [0:0] from_mem_rdata__rdy [0:0],
  input logic [0:0] recv_const__en,
  input CGRAData_32_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_5_6_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en [0:0],
  output logic [2:0] to_mem_raddr__msg [0:0],
  input logic [0:0] to_mem_raddr__rdy [0:0],
  output logic [0:0] to_mem_waddr__en [0:0],
  output logic [2:0] to_mem_waddr__msg [0:0],
  input logic [0:0] to_mem_waddr__rdy [0:0],
  output logic [0:0] to_mem_wdata__en [0:0],
  output CGRAData_32_1 to_mem_wdata__msg [0:0],
  input logic [0:0] to_mem_wdata__rdy [0:0]
);
  localparam logic [31:0] fu_list_size = 32'd1;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  //-------------------------------------------------------------
  // Component fu[0:0]
  //-------------------------------------------------------------

  logic [0:0] fu__clk [0:0] ;
  logic [0:0] fu__reset [0:0] ;
  logic [0:0] fu__from_mem_rdata__en [0:0] ;
  CGRAData_32_1 fu__from_mem_rdata__msg [0:0] ;
  logic [0:0] fu__from_mem_rdata__rdy [0:0] ;
  logic [0:0] fu__recv_const__en [0:0] ;
  CGRAData_32_1 fu__recv_const__msg [0:0] ;
  logic [0:0] fu__recv_const__rdy [0:0] ;
  logic [0:0] fu__recv_in__en [0:0][0:3] ;
  CGRAData_32_1 fu__recv_in__msg [0:0][0:3] ;
  logic [0:0] fu__recv_in__rdy [0:0][0:3] ;
  logic [0:0] fu__recv_opt__en [0:0] ;
  CGRAConfig_5_6_8 fu__recv_opt__msg [0:0] ;
  logic [0:0] fu__recv_opt__rdy [0:0] ;
  logic [0:0] fu__send_out__en [0:0][0:1] ;
  CGRAData_32_1 fu__send_out__msg [0:0][0:1] ;
  logic [0:0] fu__send_out__rdy [0:0][0:1] ;
  logic [0:0] fu__to_mem_raddr__en [0:0] ;
  logic [2:0] fu__to_mem_raddr__msg [0:0] ;
  logic [0:0] fu__to_mem_raddr__rdy [0:0] ;
  logic [0:0] fu__to_mem_waddr__en [0:0] ;
  logic [2:0] fu__to_mem_waddr__msg [0:0] ;
  logic [0:0] fu__to_mem_waddr__rdy [0:0] ;
  logic [0:0] fu__to_mem_wdata__en [0:0] ;
  CGRAData_32_1 fu__to_mem_wdata__msg [0:0] ;
  logic [0:0] fu__to_mem_wdata__rdy [0:0] ;

  Alu__69fcd339a65ec916 fu__0
  (
    .clk( fu__clk[0] ),
    .reset( fu__reset[0] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[0] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[0] ),
    .recv_const__en( fu__recv_const__en[0] ),
    .recv_const__msg( fu__recv_const__msg[0] ),
    .recv_const__rdy( fu__recv_const__rdy[0] ),
    .recv_in__en( fu__recv_in__en[0] ),
    .recv_in__msg( fu__recv_in__msg[0] ),
    .recv_in__rdy( fu__recv_in__rdy[0] ),
    .recv_opt__en( fu__recv_opt__en[0] ),
    .recv_opt__msg( fu__recv_opt__msg[0] ),
    .recv_opt__rdy( fu__recv_opt__rdy[0] ),
    .send_out__en( fu__send_out__en[0] ),
    .send_out__msg( fu__send_out__msg[0] ),
    .send_out__rdy( fu__send_out__rdy[0] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[0] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[0] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[0] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[0] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[0] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component fu[0:0]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/fu/flexible/FlexibleFu.py:64
  // @s.update
  // def comb_logic():
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en  = b1( 0 )
  // 
  //   for i in range( s.fu_list_size ):
  // 
  //     # const connection
  //     s.fu[i].recv_const.msg = s.recv_const.msg
  //     s.fu[i].recv_const.en  = s.recv_const.en
  //     s.recv_const.rdy = s.recv_const.rdy or s.fu[i].recv_const.rdy
  // 
  //     # opt connection
  //     s.fu[i].recv_opt.msg = s.recv_opt.msg
  //     s.fu[i].recv_opt.en  = s.recv_opt.en
  //     s.recv_opt.rdy       = s.fu[i].recv_opt.rdy or s.recv_opt.rdy
  // 
  //     # recv_in connection
  //     for j in range( num_inports ):
  //       s.fu[i].recv_in[j].msg = s.recv_in[j].msg
  //       s.fu[i].recv_in[j].en  = s.recv_in[j].en
  //       s.recv_in[j].rdy       = s.fu[i].recv_in[j].rdy or s.recv_in[j].rdy
  // 
  //     # send_out connection
  //     for j in range( num_outports ):
  //       if s.fu[i].send_out[j].en:
  //         s.send_out[j].msg = s.fu[i].send_out[j].msg
  //         s.send_out[j].en  = s.fu[i].send_out[j].en
  //       s.fu[i].send_out[j].rdy = s.send_out[j].rdy
  
  always_comb begin : comb_logic
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = 1'd0;
    for ( int i = 0; i < fu_list_size; i += 1 ) begin
      fu__recv_const__msg[i] = recv_const__msg;
      fu__recv_const__en[i] = recv_const__en;
      recv_const__rdy = recv_const__rdy || fu__recv_const__rdy[i];
      fu__recv_opt__msg[i] = recv_opt__msg;
      fu__recv_opt__en[i] = recv_opt__en;
      recv_opt__rdy = fu__recv_opt__rdy[i] || recv_opt__rdy;
      for ( int j = 0; j < __const__num_inports_at_comb_logic; j += 1 ) begin
        fu__recv_in__msg[i][j] = recv_in__msg[j];
        fu__recv_in__en[i][j] = recv_in__en[j];
        recv_in__rdy[j] = fu__recv_in__rdy[i][j] || recv_in__rdy[j];
      end
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 ) begin
        if ( fu__send_out__en[i][j] ) begin
          send_out__msg[j] = fu__send_out__msg[i][j];
          send_out__en[j] = fu__send_out__en[i][j];
        end
        fu__send_out__rdy[i][j] = send_out__rdy[j];
      end
    end
  end

  assign fu__clk[0] = clk;
  assign fu__reset[0] = reset;
  assign to_mem_raddr__en[0] = fu__to_mem_raddr__en[0];
  assign to_mem_raddr__msg[0] = fu__to_mem_raddr__msg[0];
  assign fu__to_mem_raddr__rdy[0] = to_mem_raddr__rdy[0];
  assign fu__from_mem_rdata__en[0] = from_mem_rdata__en[0];
  assign fu__from_mem_rdata__msg[0] = from_mem_rdata__msg[0];
  assign from_mem_rdata__rdy[0] = fu__from_mem_rdata__rdy[0];
  assign to_mem_waddr__en[0] = fu__to_mem_waddr__en[0];
  assign to_mem_waddr__msg[0] = fu__to_mem_waddr__msg[0];
  assign fu__to_mem_waddr__rdy[0] = to_mem_waddr__rdy[0];
  assign to_mem_wdata__en[0] = fu__to_mem_wdata__en[0];
  assign to_mem_wdata__msg[0] = fu__to_mem_wdata__msg[0];
  assign fu__to_mem_wdata__rdy[0] = to_mem_wdata__rdy[0];

endmodule


// PyMTL Component Tile Definition
// Full name: Tile__DataType_CGRAData_32_1__CtrlType_CGRAConfig_5_6_8__ctrl_mem_size_3__data_mem_size_8__num_ctrl_3__num_fu_inports_4__num_fu_outports_2__num_connect_inports_4__num_connect_outports_4__Fu_FlexibleFu__FuList_[<class 'PyCGRA.fu.single.Alu.Alu'>]
// At /home/ct535/project/PyCGRA/tile/Tile.py

module Tile__f271b52ddf290f3e
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_data__en [0:3],
  input CGRAData_32_1 recv_data__msg [0:3],
  output logic [0:0] recv_data__rdy [0:3],
  input logic [0:0] recv_waddr__en,
  input logic [1:0] recv_waddr__msg,
  output logic [0:0] recv_waddr__rdy,
  input logic [0:0] recv_wopt__en,
  input CGRAConfig_5_6_8 recv_wopt__msg,
  output logic [0:0] recv_wopt__rdy,
  output logic [0:0] send_data__en [0:3],
  output CGRAData_32_1 send_data__msg [0:3],
  input logic [0:0] send_data__rdy [0:3],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  //-------------------------------------------------------------
  // Component channel[0:7]
  //-------------------------------------------------------------

  logic [0:0] channel__clk [0:7] ;
  logic [0:0] channel__reset [0:7] ;
  logic [0:0] channel__recv__en [0:7] ;
  CGRAData_32_1 channel__recv__msg [0:7] ;
  logic [0:0] channel__recv__rdy [0:7] ;
  logic [0:0] channel__send__en [0:7] ;
  CGRAData_32_1 channel__send__msg [0:7] ;
  logic [0:0] channel__send__rdy [0:7] ;

  Channel__DataType_CGRAData_32_1__latency_1 channel__0
  (
    .clk( channel__clk[0] ),
    .reset( channel__reset[0] ),
    .recv__en( channel__recv__en[0] ),
    .recv__msg( channel__recv__msg[0] ),
    .recv__rdy( channel__recv__rdy[0] ),
    .send__en( channel__send__en[0] ),
    .send__msg( channel__send__msg[0] ),
    .send__rdy( channel__send__rdy[0] )
  );

  Channel__DataType_CGRAData_32_1__latency_1 channel__1
  (
    .clk( channel__clk[1] ),
    .reset( channel__reset[1] ),
    .recv__en( channel__recv__en[1] ),
    .recv__msg( channel__recv__msg[1] ),
    .recv__rdy( channel__recv__rdy[1] ),
    .send__en( channel__send__en[1] ),
    .send__msg( channel__send__msg[1] ),
    .send__rdy( channel__send__rdy[1] )
  );

  Channel__DataType_CGRAData_32_1__latency_1 channel__2
  (
    .clk( channel__clk[2] ),
    .reset( channel__reset[2] ),
    .recv__en( channel__recv__en[2] ),
    .recv__msg( channel__recv__msg[2] ),
    .recv__rdy( channel__recv__rdy[2] ),
    .send__en( channel__send__en[2] ),
    .send__msg( channel__send__msg[2] ),
    .send__rdy( channel__send__rdy[2] )
  );

  Channel__DataType_CGRAData_32_1__latency_1 channel__3
  (
    .clk( channel__clk[3] ),
    .reset( channel__reset[3] ),
    .recv__en( channel__recv__en[3] ),
    .recv__msg( channel__recv__msg[3] ),
    .recv__rdy( channel__recv__rdy[3] ),
    .send__en( channel__send__en[3] ),
    .send__msg( channel__send__msg[3] ),
    .send__rdy( channel__send__rdy[3] )
  );

  Channel__DataType_CGRAData_32_1__latency_1 channel__4
  (
    .clk( channel__clk[4] ),
    .reset( channel__reset[4] ),
    .recv__en( channel__recv__en[4] ),
    .recv__msg( channel__recv__msg[4] ),
    .recv__rdy( channel__recv__rdy[4] ),
    .send__en( channel__send__en[4] ),
    .send__msg( channel__send__msg[4] ),
    .send__rdy( channel__send__rdy[4] )
  );

  Channel__DataType_CGRAData_32_1__latency_1 channel__5
  (
    .clk( channel__clk[5] ),
    .reset( channel__reset[5] ),
    .recv__en( channel__recv__en[5] ),
    .recv__msg( channel__recv__msg[5] ),
    .recv__rdy( channel__recv__rdy[5] ),
    .send__en( channel__send__en[5] ),
    .send__msg( channel__send__msg[5] ),
    .send__rdy( channel__send__rdy[5] )
  );

  Channel__DataType_CGRAData_32_1__latency_1 channel__6
  (
    .clk( channel__clk[6] ),
    .reset( channel__reset[6] ),
    .recv__en( channel__recv__en[6] ),
    .recv__msg( channel__recv__msg[6] ),
    .recv__rdy( channel__recv__rdy[6] ),
    .send__en( channel__send__en[6] ),
    .send__msg( channel__send__msg[6] ),
    .send__rdy( channel__send__rdy[6] )
  );

  Channel__DataType_CGRAData_32_1__latency_1 channel__7
  (
    .clk( channel__clk[7] ),
    .reset( channel__reset[7] ),
    .recv__en( channel__recv__en[7] ),
    .recv__msg( channel__recv__msg[7] ),
    .recv__rdy( channel__recv__rdy[7] ),
    .send__en( channel__send__en[7] ),
    .send__msg( channel__send__msg[7] ),
    .send__rdy( channel__send__rdy[7] )
  );

  //-------------------------------------------------------------
  // End of component channel[0:7]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component crossbar
  //-------------------------------------------------------------

  logic [0:0] crossbar__clk ;
  logic [0:0] crossbar__reset ;
  logic [0:0] crossbar__recv_data__en [0:5] ;
  CGRAData_32_1 crossbar__recv_data__msg [0:5] ;
  logic [0:0] crossbar__recv_data__rdy [0:5] ;
  logic [0:0] crossbar__recv_opt__en ;
  CGRAConfig_5_6_8 crossbar__recv_opt__msg ;
  logic [0:0] crossbar__recv_opt__rdy ;
  logic [0:0] crossbar__send_data__en [0:7] ;
  CGRAData_32_1 crossbar__send_data__msg [0:7] ;
  logic [0:0] crossbar__send_data__rdy [0:7] ;

  Crossbar__9de0b627a60fd452 crossbar
  (
    .clk( crossbar__clk ),
    .reset( crossbar__reset ),
    .recv_data__en( crossbar__recv_data__en ),
    .recv_data__msg( crossbar__recv_data__msg ),
    .recv_data__rdy( crossbar__recv_data__rdy ),
    .recv_opt__en( crossbar__recv_opt__en ),
    .recv_opt__msg( crossbar__recv_opt__msg ),
    .recv_opt__rdy( crossbar__recv_opt__rdy ),
    .send_data__en( crossbar__send_data__en ),
    .send_data__msg( crossbar__send_data__msg ),
    .send_data__rdy( crossbar__send_data__rdy )
  );

  //-------------------------------------------------------------
  // End of component crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_mem
  //-------------------------------------------------------------

  logic [0:0] ctrl_mem__clk ;
  logic [0:0] ctrl_mem__reset ;
  logic [0:0] ctrl_mem__recv_ctrl__en ;
  CGRAConfig_5_6_8 ctrl_mem__recv_ctrl__msg ;
  logic [0:0] ctrl_mem__recv_ctrl__rdy ;
  logic [0:0] ctrl_mem__recv_waddr__en ;
  logic [1:0] ctrl_mem__recv_waddr__msg ;
  logic [0:0] ctrl_mem__recv_waddr__rdy ;
  logic [0:0] ctrl_mem__send_ctrl__en ;
  CGRAConfig_5_6_8 ctrl_mem__send_ctrl__msg ;
  logic [0:0] ctrl_mem__send_ctrl__rdy ;

  CtrlMem__CtrlType_CGRAConfig_5_6_8__ctrl_mem_size_3__num_ctrl_3 ctrl_mem
  (
    .clk( ctrl_mem__clk ),
    .reset( ctrl_mem__reset ),
    .recv_ctrl__en( ctrl_mem__recv_ctrl__en ),
    .recv_ctrl__msg( ctrl_mem__recv_ctrl__msg ),
    .recv_ctrl__rdy( ctrl_mem__recv_ctrl__rdy ),
    .recv_waddr__en( ctrl_mem__recv_waddr__en ),
    .recv_waddr__msg( ctrl_mem__recv_waddr__msg ),
    .recv_waddr__rdy( ctrl_mem__recv_waddr__rdy ),
    .send_ctrl__en( ctrl_mem__send_ctrl__en ),
    .send_ctrl__msg( ctrl_mem__send_ctrl__msg ),
    .send_ctrl__rdy( ctrl_mem__send_ctrl__rdy )
  );

  //-------------------------------------------------------------
  // End of component ctrl_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component element
  //-------------------------------------------------------------

  logic [0:0] element__clk ;
  logic [0:0] element__reset ;
  logic [0:0] element__from_mem_rdata__en [0:0] ;
  CGRAData_32_1 element__from_mem_rdata__msg [0:0] ;
  logic [0:0] element__from_mem_rdata__rdy [0:0] ;
  logic [0:0] element__recv_const__en ;
  CGRAData_32_1 element__recv_const__msg ;
  logic [0:0] element__recv_const__rdy ;
  logic [0:0] element__recv_in__en [0:3] ;
  CGRAData_32_1 element__recv_in__msg [0:3] ;
  logic [0:0] element__recv_in__rdy [0:3] ;
  logic [0:0] element__recv_opt__en ;
  CGRAConfig_5_6_8 element__recv_opt__msg ;
  logic [0:0] element__recv_opt__rdy ;
  logic [0:0] element__send_out__en [0:1] ;
  CGRAData_32_1 element__send_out__msg [0:1] ;
  logic [0:0] element__send_out__rdy [0:1] ;
  logic [0:0] element__to_mem_raddr__en [0:0] ;
  logic [2:0] element__to_mem_raddr__msg [0:0] ;
  logic [0:0] element__to_mem_raddr__rdy [0:0] ;
  logic [0:0] element__to_mem_waddr__en [0:0] ;
  logic [2:0] element__to_mem_waddr__msg [0:0] ;
  logic [0:0] element__to_mem_waddr__rdy [0:0] ;
  logic [0:0] element__to_mem_wdata__en [0:0] ;
  CGRAData_32_1 element__to_mem_wdata__msg [0:0] ;
  logic [0:0] element__to_mem_wdata__rdy [0:0] ;

  FlexibleFu__4cb8ece074a97746 element
  (
    .clk( element__clk ),
    .reset( element__reset ),
    .from_mem_rdata__en( element__from_mem_rdata__en ),
    .from_mem_rdata__msg( element__from_mem_rdata__msg ),
    .from_mem_rdata__rdy( element__from_mem_rdata__rdy ),
    .recv_const__en( element__recv_const__en ),
    .recv_const__msg( element__recv_const__msg ),
    .recv_const__rdy( element__recv_const__rdy ),
    .recv_in__en( element__recv_in__en ),
    .recv_in__msg( element__recv_in__msg ),
    .recv_in__rdy( element__recv_in__rdy ),
    .recv_opt__en( element__recv_opt__en ),
    .recv_opt__msg( element__recv_opt__msg ),
    .recv_opt__rdy( element__recv_opt__rdy ),
    .send_out__en( element__send_out__en ),
    .send_out__msg( element__send_out__msg ),
    .send_out__rdy( element__send_out__rdy ),
    .to_mem_raddr__en( element__to_mem_raddr__en ),
    .to_mem_raddr__msg( element__to_mem_raddr__msg ),
    .to_mem_raddr__rdy( element__to_mem_raddr__rdy ),
    .to_mem_waddr__en( element__to_mem_waddr__en ),
    .to_mem_waddr__msg( element__to_mem_waddr__msg ),
    .to_mem_waddr__rdy( element__to_mem_waddr__rdy ),
    .to_mem_wdata__en( element__to_mem_wdata__en ),
    .to_mem_wdata__msg( element__to_mem_wdata__msg ),
    .to_mem_wdata__rdy( element__to_mem_wdata__rdy )
  );

  //-------------------------------------------------------------
  // End of component element
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At /home/ct535/project/PyCGRA/tile/Tile.py:106
  // @s.update
  // def update_opt():
  //   s.element.recv_opt.msg  = s.ctrl_mem.send_ctrl.msg
  //   s.crossbar.recv_opt.msg = s.ctrl_mem.send_ctrl.msg
  //   s.element.recv_opt.en  = s.ctrl_mem.send_ctrl.en
  //   s.crossbar.recv_opt.en = s.ctrl_mem.send_ctrl.en
  //   s.ctrl_mem.send_ctrl.rdy = s.element.recv_opt.rdy and s.crossbar.recv_opt.rdy
  
  always_comb begin : update_opt
    element__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    crossbar__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    element__recv_opt__en = ctrl_mem__send_ctrl__en;
    crossbar__recv_opt__en = ctrl_mem__send_ctrl__en;
    ctrl_mem__send_ctrl__rdy = element__recv_opt__rdy && crossbar__recv_opt__rdy;
  end

  assign element__clk = clk;
  assign element__reset = reset;
  assign crossbar__clk = clk;
  assign crossbar__reset = reset;
  assign ctrl_mem__clk = clk;
  assign ctrl_mem__reset = reset;
  assign channel__clk[0] = clk;
  assign channel__reset[0] = reset;
  assign channel__clk[1] = clk;
  assign channel__reset[1] = reset;
  assign channel__clk[2] = clk;
  assign channel__reset[2] = reset;
  assign channel__clk[3] = clk;
  assign channel__reset[3] = reset;
  assign channel__clk[4] = clk;
  assign channel__reset[4] = reset;
  assign channel__clk[5] = clk;
  assign channel__reset[5] = reset;
  assign channel__clk[6] = clk;
  assign channel__reset[6] = reset;
  assign channel__clk[7] = clk;
  assign channel__reset[7] = reset;
  assign ctrl_mem__recv_waddr__en = recv_waddr__en;
  assign ctrl_mem__recv_waddr__msg = recv_waddr__msg;
  assign recv_waddr__rdy = ctrl_mem__recv_waddr__rdy;
  assign ctrl_mem__recv_ctrl__en = recv_wopt__en;
  assign ctrl_mem__recv_ctrl__msg = recv_wopt__msg;
  assign recv_wopt__rdy = ctrl_mem__recv_ctrl__rdy;
  assign element__to_mem_raddr__rdy[0] = 1'd0;
  assign element__from_mem_rdata__en[0] = 1'd0;
  assign element__from_mem_rdata__msg[0] = { 32'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[0] = 1'd0;
  assign element__to_mem_wdata__rdy[0] = 1'd0;
  assign crossbar__recv_data__en[0] = recv_data__en[0];
  assign crossbar__recv_data__msg[0] = recv_data__msg[0];
  assign recv_data__rdy[0] = crossbar__recv_data__rdy[0];
  assign crossbar__recv_data__en[1] = recv_data__en[1];
  assign crossbar__recv_data__msg[1] = recv_data__msg[1];
  assign recv_data__rdy[1] = crossbar__recv_data__rdy[1];
  assign crossbar__recv_data__en[2] = recv_data__en[2];
  assign crossbar__recv_data__msg[2] = recv_data__msg[2];
  assign recv_data__rdy[2] = crossbar__recv_data__rdy[2];
  assign crossbar__recv_data__en[3] = recv_data__en[3];
  assign crossbar__recv_data__msg[3] = recv_data__msg[3];
  assign recv_data__rdy[3] = crossbar__recv_data__rdy[3];
  assign channel__recv__en[0] = crossbar__send_data__en[0];
  assign channel__recv__msg[0] = crossbar__send_data__msg[0];
  assign crossbar__send_data__rdy[0] = channel__recv__rdy[0];
  assign channel__recv__en[1] = crossbar__send_data__en[1];
  assign channel__recv__msg[1] = crossbar__send_data__msg[1];
  assign crossbar__send_data__rdy[1] = channel__recv__rdy[1];
  assign channel__recv__en[2] = crossbar__send_data__en[2];
  assign channel__recv__msg[2] = crossbar__send_data__msg[2];
  assign crossbar__send_data__rdy[2] = channel__recv__rdy[2];
  assign channel__recv__en[3] = crossbar__send_data__en[3];
  assign channel__recv__msg[3] = crossbar__send_data__msg[3];
  assign crossbar__send_data__rdy[3] = channel__recv__rdy[3];
  assign channel__recv__en[4] = crossbar__send_data__en[4];
  assign channel__recv__msg[4] = crossbar__send_data__msg[4];
  assign crossbar__send_data__rdy[4] = channel__recv__rdy[4];
  assign channel__recv__en[5] = crossbar__send_data__en[5];
  assign channel__recv__msg[5] = crossbar__send_data__msg[5];
  assign crossbar__send_data__rdy[5] = channel__recv__rdy[5];
  assign channel__recv__en[6] = crossbar__send_data__en[6];
  assign channel__recv__msg[6] = crossbar__send_data__msg[6];
  assign crossbar__send_data__rdy[6] = channel__recv__rdy[6];
  assign channel__recv__en[7] = crossbar__send_data__en[7];
  assign channel__recv__msg[7] = crossbar__send_data__msg[7];
  assign crossbar__send_data__rdy[7] = channel__recv__rdy[7];
  assign send_data__en[0] = channel__send__en[0];
  assign send_data__msg[0] = channel__send__msg[0];
  assign channel__send__rdy[0] = send_data__rdy[0];
  assign send_data__en[1] = channel__send__en[1];
  assign send_data__msg[1] = channel__send__msg[1];
  assign channel__send__rdy[1] = send_data__rdy[1];
  assign send_data__en[2] = channel__send__en[2];
  assign send_data__msg[2] = channel__send__msg[2];
  assign channel__send__rdy[2] = send_data__rdy[2];
  assign send_data__en[3] = channel__send__en[3];
  assign send_data__msg[3] = channel__send__msg[3];
  assign channel__send__rdy[3] = send_data__rdy[3];
  assign element__recv_in__en[0] = channel__send__en[4];
  assign element__recv_in__msg[0] = channel__send__msg[4];
  assign channel__send__rdy[4] = element__recv_in__rdy[0];
  assign element__recv_in__en[1] = channel__send__en[5];
  assign element__recv_in__msg[1] = channel__send__msg[5];
  assign channel__send__rdy[5] = element__recv_in__rdy[1];
  assign element__recv_in__en[2] = channel__send__en[6];
  assign element__recv_in__msg[2] = channel__send__msg[6];
  assign channel__send__rdy[6] = element__recv_in__rdy[2];
  assign element__recv_in__en[3] = channel__send__en[7];
  assign element__recv_in__msg[3] = channel__send__msg[7];
  assign channel__send__rdy[7] = element__recv_in__rdy[3];
  assign crossbar__recv_data__en[4] = element__send_out__en[0];
  assign crossbar__recv_data__msg[4] = element__send_out__msg[0];
  assign element__send_out__rdy[0] = crossbar__recv_data__rdy[4];
  assign crossbar__recv_data__en[5] = element__send_out__en[1];
  assign crossbar__recv_data__msg[5] = element__send_out__msg[1];
  assign element__send_out__rdy[1] = crossbar__recv_data__rdy[5];

endmodule
