//-------------------------------------------------------------------------
// VectorAdderRTL__65a6399a04a67573.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct CGRAConfig_6_2_5_5 Definition
// At BitStruct CGRAConfig_6_2_5_5
typedef struct packed {
  logic [5:0] ctrl ;
  logic [0:0] predicate ;
  logic [1:0][1:0] fu_in ;
  logic [4:0][2:0] outport ;
  logic [4:0][0:0] predicate_in ;
} CGRAConfig_6_2_5_5;

// PyMTL Component VectorAdderRTL Definition
// Full name: VectorAdderRTL__bw_8__CtrlType_CGRAConfig_6_2_5_5__num_inports_2__num_outports_1__data_mem_size_8
// At /home/rms/repos/RecoNTT-CGRA/VectorCGRA/fu/vector/VectorAdderRTL.py

module VectorAdderRTL__65a6399a04a67573
(
  input logic [0:0] carry_in,
  output logic [0:0] carry_out,
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:1],
  input logic [0:0] reset,
  input logic [0:0] recv_const__en,
  input logic [8:0] recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:1],
  input logic [8:0] recv_in__msg [0:1],
  output logic [0:0] recv_in__rdy [0:1],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_2_5_5 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  output logic [0:0] send_out__en [0:0],
  output logic [8:0] send_out__msg [0:0],
  input logic [0:0] send_out__rdy [0:0]
);
  localparam logic [8:0] const_one = 9'd1;
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd1;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd2;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd1;
  localparam logic [5:0] __const__OPT_ADD = 6'd2;
  localparam logic [5:0] __const__OPT_ADD_CONST = 6'd25;
  localparam logic [5:0] __const__OPT_INC = 6'd3;
  localparam logic [5:0] __const__OPT_SUB = 6'd4;
  localparam logic [5:0] __const__OPT_SUB_CONST = 6'd36;
  localparam logic [5:0] __const__OPT_PAS = 6'd31;
  localparam logic [31:0] __const__bw_at_comb_logic = 32'd8;
  logic [8:0] carry_in_temp ;
  logic [1:0] __tmpvar__comb_logic_in0 ;
  logic [1:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At /home/rms/repos/RecoNTT-CGRA/VectorCGRA/fu/vector/VectorAdderRTL.py:52
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.carry_in_temp[0] = s.carry_in
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  // 
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  // 
  //   if s.recv_opt.msg.ctrl == OPT_ADD:
  //     s.send_out[0].msg = s.recv_in[in0].msg + s.recv_in[in1].msg + s.carry_in_temp
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_ADD_CONST:
  //     s.send_out[0].msg = s.recv_in[in0].msg + s.recv_const.msg + s.carry_in_temp
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_INC:
  //     s.send_out[0].msg = s.recv_in[in0].msg + s.const_one
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_SUB:
  //     s.send_out[0].msg = s.recv_in[in0].msg - s.recv_in[in1].msg - s.carry_in_temp
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_SUB_CONST:
  //     s.send_out[0].msg = s.recv_in[in0].msg - s.recv_const.msg - s.carry_in_temp
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_PAS:
  //     s.send_out[0].msg = s.recv_in[in0].msg
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   s.carry_out = s.send_out[0].msg[bw:bw+1]
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 2'd0;
    __tmpvar__comb_logic_in1 = 2'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    carry_in_temp[0] = carry_in;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 2'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 2'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 2'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 2'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_ADD ) begin
      send_out__msg[0] = ( recv_in__msg[__tmpvar__comb_logic_in0] + recv_in__msg[__tmpvar__comb_logic_in1] ) + carry_in_temp;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_ADD_CONST ) begin
      send_out__msg[0] = ( recv_in__msg[__tmpvar__comb_logic_in0] + recv_const__msg ) + carry_in_temp;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_INC ) begin
      send_out__msg[0] = recv_in__msg[__tmpvar__comb_logic_in0] + const_one;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_SUB ) begin
      send_out__msg[0] = ( recv_in__msg[__tmpvar__comb_logic_in0] - recv_in__msg[__tmpvar__comb_logic_in1] ) - carry_in_temp;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_SUB_CONST ) begin
      send_out__msg[0] = ( recv_in__msg[__tmpvar__comb_logic_in0] - recv_const__msg ) - carry_in_temp;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_PAS ) begin
      send_out__msg[0] = recv_in__msg[__tmpvar__comb_logic_in0];
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    carry_out = send_out__msg[0][__const__bw_at_comb_logic +: 1];
  end

  // PyMTL Update Block Source
  // At /home/rms/repos/RecoNTT-CGRA/VectorCGRA/fu/vector/VectorAdderRTL.py:46
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule
